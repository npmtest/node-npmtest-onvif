{"/home/travis/build/npmtest/node-npmtest-onvif/test.js":"/* istanbul instrument in package npmtest_onvif */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-onvif/lib.npmtest_onvif.js":"/* istanbul instrument in package npmtest_onvif */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_onvif = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_onvif = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-onvif/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-onvif && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_onvif */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_onvif\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_onvif.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_onvif.rollup.js'] =\n            local.assetsDict['/assets.npmtest_onvif.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_onvif.__dirname + '/lib.npmtest_onvif.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/onvif.js":"/**\n * @description Common module for ONVIF library\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nmodule.exports = {\n\tCam: require('./cam').Cam\n\t, Discovery: require('./discovery').Discovery\n};","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/cam.js":"/**\n * @namespace cam\n * @description Common camera module\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nconst http = require('http')\n\t, crypto = require('crypto')\n\t, util = require('util')\n\t, events = require('events')\n\t, url = require('url')\n\t, linerase = require('./utils').linerase\n\t, parseSOAPString = require('./utils').parseSOAPString\n\t, emptyFn = function() {}\n\t;\n\n/**\n * @callback Cam~MessageCallback\n * @property {?Error} error\n * @property {?string} message\n */\n\n/**\n * @callback Cam~ConnectionCallback\n * @property {?Error} error\n */\n\n/**\n * Camera class\n * @param {object} options\n * @param {string} options.hostname\n * @param {string} [options.username]\n * @param {string} [options.password]\n * @param {number} [options.port=80]\n * @param {string} [options.path=/onvif/device_service]\n * @param {number} [options.timeout=120000]\n * @param {boolean} [options.preserveAddress=false] Force using hostname and port from constructor for the services\n * @param {Cam~ConnectionCallback} [callback]\n * @fires Cam#rawRequest\n * @fires Cam#rawResponse\n * @fires Cam#connect\n * @fires Cam#event\n * @property presets\n * @class\n * @constructor\n * @extends events.EventEmitter\n * @example\n * var\n *   http = require('http'),\n *   Cam = require('onvif').Cam;\n *\n * new Cam({\n *   hostname: <CAMERA_HOST>,\n *   username: <USERNAME>,\n *   password: <PASSWORD>\n * }, function(err) {\n *   this.absoluteMove({x: 1, y: 1, zoom: 1});\n *   this.getStreamUri({protocol:'RTSP'}, function(err, stream) {\n *     http.createServer(function (req, res) {\n *       res.writeHead(200, {'Content-Type': 'text/html'});\n *       res.end('<html><body>' +\n *         '<embed type=\"application/x-vlc-plugin\" target=\"' + stream.uri + '\"></embed>' +\n *         '</body></html>');\n *     }).listen(3030);\n *   });\n * });\n */\nvar Cam = function(options, callback) {\n\tcallback = callback || emptyFn;\n\tthis.hostname = options.hostname;\n\tthis.username = options.username;\n\tthis.password = options.password;\n\tthis.port = options.port || 80;\n\tthis.path = options.path || '/onvif/device_service';\n\tthis.timeout = options.timeout || 120000;\n\t/**\n\t * Force using hostname and port from constructor for the services\n\t * @type {boolean}\n\t */\n\tthis.preserveAddress = options.preserveAddress || false;\n\n\tthis.events = {};\n\tsetImmediate(function() {\n\t\tthis.connect(callback);\n\t}.bind(this));\n};\n\n// events.EventEmitter inheritance\nutil.inherits(Cam, events.EventEmitter);\n\n/**\n * Connect to the camera and fill device information properties\n * @param {Cam~ConnectionCallback} callback\n */\nCam.prototype.connect = function(callback) {\n\n\t// Must execute getSystemDataAndTime (and wait for callback)\n\t// before any other ONVIF commands so that the time of the ONVIF device\n\t// is known\n\t\n\tthis.getSystemDateAndTime(function(err, date, xml) {\n\t\tif (err) {\n\t\t\tcallback.call(this, err, null, xml);\n\t\t}\n\t\tthis.getCapabilities(function(err, data, xml) {\n\t\t\tif (err) {\n\t\t\t\tcallback.call(this, err, null, xml);\n\t\t\t} else {\n\t\t\t\tvar upstartFunctions = [];\n\n\t\t\t\t// Profile S\n\t\t\t\tif (data && data.media && data.media.XAddr) {\n\t\t\t\t\tupstartFunctions.push(this.getProfiles);\n\t\t\t\t\tupstartFunctions.push(this.getVideoSources);\n\t\t\t\t}\n\n\t\t\t\tvar count = upstartFunctions.length;\n\t\t\t\tvar errCall = false;\n\n\t\t\t\tif (count > 0) {\n\t\t\t\t\tupstartFunctions.forEach(function(fun) {\n\t\t\t\t\t\tfun.call(this, function(err) {\n\t\t\t\t\t\t\tif (err && !errCall) {\n\t\t\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\t\t\tcallback.call(this, err);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\terrCall = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (!--count) {\n\t\t\t\t\t\t\t\t\tthis.getActiveSources();\n\t\t\t\t\t\t\t\t\tthis.emit('connect');\n\t\t\t\t\t\t\t\t\tif (callback) {\n\t\t\t\t\t\t\t\t\t\tcallback.call(this, err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}.bind(this));\n\t\t\t\t\t}.bind(this));\n\t\t\t\t} else {\n\t\t\t\t\tthis.emit('connect');\n\t\t\t\t\tif (callback) {\n\t\t\t\t\t\tcallback.call(this, false);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}.bind(this));\n\t}.bind(this));\n};\n\n/**\n * @callback Cam~RequestCallback\n * @param {Error} err\n * @param {object} [response] message\n * @param {string} [xml] response\n */\n\n/**\n * Common camera request\n * @param {object} options\n * @param {string} [options.service] Name of service (ptz, media, etc)\n * @param {string} options.body SOAP body\n * @param {string} [options.url] Defines another url to request\n * @param {boolean} [options.ptz] make request to PTZ uri or not\n * @param {Cam~RequestCallback} callback response callback\n * @private\n */\nCam.prototype._request = function(options, callback) {\n\tvar _this = this;\n\tvar callbackExecuted = false;\n\tvar reqOptions = options.url || {\n\t\t\thostname: this.hostname\n\t\t\t, port: this.port\n\t\t\t, path: options.service\n\t\t\t\t? (this.uri[options.service] ? this.uri[options.service].path : options.service)\n\t\t\t\t: this.path\n\t\t};\n\treqOptions.headers = {\n\t\t'Content-Type': 'application/soap+xml'\n\t\t, 'Content-Length': options.body.length\n\t\t, charset: 'utf-8'\n\t};\n\n\treqOptions.method = 'POST';\n\tvar req = http.request(reqOptions, function(res) {\n\t\tvar bufs = [], length = 0;\n\t\tres.on('data', function(chunk) {\n\t\t\tbufs.push(chunk);\n\t\t\tlength += chunk.length;\n\t\t});\n\t\tres.on('end', function() {\n\t\t\tif (callbackExecuted === true) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar xml = Buffer.concat(bufs, length).toString('utf8');\n\t\t\t/**\n\t\t\t * Indicates raw xml response from device.\n\t\t\t * @event Cam#rawResponse\n\t\t\t * @type {string}\n\t\t\t */\n\t\t\t_this.emit('rawResponse', xml);\n\t\t\tparseSOAPString(xml, callback);\n\t\t\tcallbackExecuted = true;\n\t\t});\n\t});\n\n\treq.setTimeout(this.timeout, function() {\n\t\tif (callbackExecuted === true) {\n\t\t\treturn;\n\t\t}\n\t\tcallback(new Error('Network timeout'));\n\t\tcallbackExecuted = true;\n\t});\n\treq.on('error', function(err) {\n\t\tif (callbackExecuted === true) {\n\t\t\treturn;\n\t\t}\n\t\t/* address, port number or IPCam error */\n\t\tif (err.code === 'ECONNREFUSED' && err.errno === 'ECONNREFUSED'  && err.syscall === 'connect') {\n\t\t\tcallback(err);\n\t\t/* network error */\n\t\t} else if (err.code === 'ECONNRESET' && err.errno === 'ECONNRESET'  && err.syscall === 'read') {\n\t\t\tcallback(err);\n\t\t} else {\n\t\t\tcallback(err);\n\t\t}\n\t\tcallbackExecuted = true;\n\t});\n\tthis.emit('rawRequest', options.body);\n\treq.write(options.body);\n\treq.end();\n};\n\n/**\n * @callback Cam~DateTimeCallback\n * @property {?Error} error\n * @property {Date} dateTime Date object of current device's dateTime\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive date and time from cam\n * @param {Cam~DateTimeCallback} callback\n */\nCam.prototype.getSystemDateAndTime = function(callback) {\n\tthis._request({\n\t\tbody:\n\t\t'<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\">' +\n\t\t\t'<s:Body xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">' +\n\t\t\t\t'<GetSystemDateAndTime xmlns=\"http://www.onvif.org/ver10/device/wsdl\"/>' +\n\t\t\t'</s:Body>' +\n\t\t'</s:Envelope>'\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tvar dt = linerase(data[0]['getSystemDateAndTimeResponse'][0]['systemDateAndTime'][0]['UTCDateTime'][0])\n\t\t\t\t, time = new Date(Date.UTC(dt.date.year, dt.date.month - 1, dt.date.day, dt.time.hour, dt.time.minute, dt.time.second))\n\t\t\t\t;\n\t\t\tif (!this.timeShift) {\n\t\t\t\tthis.timeShift = time - Date.now();\n\t\t\t}\n\t\t}\n\t\tcallback.call(this, err, time, xml);\n\t}.bind(this));\n};\n\n\n/**\n * @typedef {object} Cam~SystemDateAndTime\n * @property {string} dayTimeType (Manual | NTP)\n * @property {boolean} daylightSavings\n * @property {string} timezone in POSIX 1003.1 format\n * @property {number} hour\n * @property {number} minute\n * @property {number} second\n * @property {number} year\n * @property {number} month\n * @property {number} day\n */\n\n/**\n * Set the device system date and time\n * @param {object} options\n * @param {Date} [options.dateTime]\n * @param {string} options.dateTimeType (Manual | NTP)\n * @param {boolean} [options.daylightSavings=false]\n * @patam {string} [options.timezone]\n * @param {Cam~DateTimeCallback} callback\n */\nCam.prototype.setSystemDateAndTime = function(options, callback) {\n\tif (['Manual', 'NTP'].indexOf(options.dateTimeType) === -1) {\n\t\treturn callback(new Error('DateTimeType should be `Manual` or `NTP`'));\n\t}\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<SetSystemDateAndTime xmlns=\"http://www.onvif.org/ver10/device/wsdl\">' +\n\t\t\t'<DateTimeType>' +\n\t\t\t\toptions.dateTimeType +\n\t\t\t'</DateTimeType>' +\n\t\t\t'<DaylightSavings>' +\n\t\t\t\t( !!options.daylightSavings ) +\n\t\t\t'</DaylightSavings>' +\n\t\t\t( options.timezone !== undefined ?\n\t\t\t'<TimeZone>' +\n\t\t\t\t'<TZ xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\toptions.timezone +\n\t\t\t\t'</TZ>' +\n\t\t\t'</TimeZone>' : '' ) +\n\t\t\t// ( options.dateTime !== undefined && options.dateTime.getDate instanceof Date ?\n\t\t\t( options.dateTime !== undefined && options.dateTime instanceof Date ?\n\t\t\t'<UTCDateTime>' +\n\t\t\t\t'<Time xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t'<Hour>' + options.dateTime.getUTCHours() + '</Hour>' +\n\t\t\t\t\t'<Minute>' + options.dateTime.getUTCMinutes() + '</Minute>' +\n\t\t\t\t\t'<Second>' + options.dateTime.getUTCSeconds() + '</Second>' +\n\t\t\t\t'</Time>' +\n\t\t\t\t'<Date xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t'<Year>' + options.dateTime.getUTCFullYear() + '</Year>' +\n\t\t\t\t\t'<Month>' + (options.dateTime.getUTCMonth() + 1) + '</Month>' +\n\t\t\t\t\t'<Day>' + options.dateTime.getUTCDate() + '</Day>' +\n\t\t\t\t'</Date>' +\n\t\t\t'</UTCDateTime>' : '' ) +\n\t\t'</SetSystemDateAndTime>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (err || linerase(data).setSystemDateAndTimeResponse !== '') {\n\t\t\treturn callback.call(this, linerase(data).setSystemDateAndTimeResponse !== ''\n\t\t\t\t? new Error('Wrong `SetSystemDateAndTime` response')\n\t\t\t\t: err, data, xml);\n\t\t}\n\t\t//get new system time from device\n\t\tthis.getSystemDateAndTime(callback);\n\t}.bind(this));\n};\n\n/**\n * Capability list\n * @typedef {object} Cam~Capabilities\n * @property {object} device Device capabilities\n * @property {string} device.XAddr Device service URI\n * @property {object} [device.network] Network capabilities\n * @property {boolean} device.network.IPFilter Indicates support for IP filtering\n * @property {boolean} device.network.zeroConfiguration Indicates support for zeroconf\n * @property {boolean} device.network.IPVersion6 Indicates support for IPv6\n * @property {boolean} device.network.dynDNS Indicates support for dynamic DNS configuration\n * @property {object} [device.system] System capabilities\n * @property {boolean} device.system.discoveryResolve Indicates support for WS Discovery resolve requests\n * @property {boolean} device.system.discoveryBye Indicates support for WS-Discovery Bye\n * @property {boolean} device.system.remoteDiscovery Indicates support for remote discovery\n * @property {boolean} device.system.systemBackup Indicates support for system backup through MTOM\n * @property {boolean} device.system.systemLogging Indicates support for retrieval of system logging through MTOM\n * @property {boolean} device.system.firmwareUpgrade Indicates support for firmware upgrade through MTOM\n * @property {boolean} device.system.httpFirmwareUpgrade Indicates support for firmware upgrade through HTTP\n * @property {boolean} device.system.httpSystemBackup Indicates support for system backup through HTTP\n * @property {boolean} device.system.httpSystemLogging Indicates support for retrieval of system logging through HTTP\n * @property {object} [device.IO] I/O capabilities\n * @property {number} device.IO.inputConnectors Number of input connectors\n * @property {number} device.IO.relayOutputs Number of relay outputs\n * @property {object} [device.IO.extension]\n * @property {boolean} device.IO.extension.auxiliary\n * @property {object} device.IO.extension.auxiliaryCommands\n * @property {object} [device.security] Security capabilities\n * @property {boolean} device.security.'TLS1.1' Indicates support for TLS 1.1\n * @property {boolean} device.security.'TLS1.2' Indicates support for TLS 1.2\n * @property {boolean} device.security.onboardKeyGeneration Indicates support for onboard key generation\n * @property {boolean} device.security.accessPolicyConfig Indicates support for access policy configuration\n * @property {boolean} device.security.'X.509Token' Indicates support for WS-Security X.509 token\n * @property {boolean} device.security.SAMLToken Indicates support for WS-Security SAML token\n * @property {boolean} device.security.kerberosToken Indicates support for WS-Security Kerberos token\n * @property {boolean} device.security.RELToken Indicates support for WS-Security REL token\n * @property {object} events Event capabilities\n * @property {string} events.XAddr Event service URI\n * @property {boolean} events.WSSubscriptionPolicySupport Indicates whether or not WS Subscription policy is supported\n * @property {boolean} events.WSPullPointSupport Indicates whether or not WS Pull Point is supported\n * @property {boolean} events.WSPausableSubscriptionManagerInterfaceSupport Indicates whether or not WS Pausable Subscription Manager Interface is supported\n * @property {object} imaging Imaging capabilities\n * @property {string} imaging.XAddr Imaging service URI\n * @property {object} media Media capabilities\n * @property {string} media.XAddr Media service URI\n * @property {object} media.streamingCapabilities Streaming capabilities\n * @property {boolean} media.streamingCapabilities.RTPMulticast Indicates whether or not RTP multicast is supported\n * @property {boolean} media.streamingCapabilities.RTP_TCP Indicates whether or not RTP over TCP is supported\n * @property {boolean} media.streamingCapabilities.RTP_RTSP_TCP Indicates whether or not RTP/RTSP/TCP is supported\n * @property {object} media.streamingCapabilities.extension\n * @property {object} PTZ PTZ capabilities\n * @property {string} PTZ.XAddr PTZ service URI\n * @property {object} [extension]\n * @property {object} extension.deviceIO DeviceIO capabilities\n * @property {string} extension.deviceIO.XAddr DeviceIO service URI\n * @property {number} extension.deviceIO.videoSources\n * @property {number} extension.deviceIO.videoOutputs\n * @property {number} extension.deviceIO.audioSources\n * @property {number} extension.deviceIO.audioOutputs\n * @property {number} extension.deviceIO.relayOutputs\n * @property {object} [extension.extensions]\n * @property {object} [extension.extensions.telexCapabilities]\n * @property {object} [extension.extensions.scdlCapabilities]\n */\n\n/**\n * @callback Cam~GetCapabilitiesCallback\n * @property {?Error} error\n * @property {Cam~Capabilities} capabilities\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive cam capabilities\n * @param {Cam~GetCapabilitiesCallback} [callback]\n */\nCam.prototype.getCapabilities = function(callback) {\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<GetCapabilities xmlns=\"http://www.onvif.org/ver10/device/wsdl\">' +\n\t\t'<Category>All</Category>' +\n\t\t'</GetCapabilities>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\t/**\n\t\t\t * Device capabilities\n\t\t\t * @name Cam#capabilities\n\t\t\t * @type {Cam~Capabilities}\n\t\t\t */\n\t\t\tthis.capabilities = linerase(data[0]['getCapabilitiesResponse'][0]['capabilities'][0]);\n\t\t\t// fill Cam#uri property\n\t\t\tif (!this.uri) {\n\t\t\t\t/**\n\t\t\t\t * Device service URIs\n\t\t\t\t * @name Cam#uri\n\t\t\t\t * @property {url} [PTZ]\n\t\t\t\t * @property {url} [media]\n\t\t\t\t * @property {url} [imaging]\n\t\t\t\t * @property {url} [events]\n\t\t\t\t * @property {url} [device]\n\t\t\t\t */\n\t\t\t\tthis.uri = {};\n\t\t\t}\n\t\t\t['PTZ', 'media', 'imaging', 'events', 'device'].forEach(function(name) {\n\t\t\t\tif (this.capabilities[name] && this.capabilities[name].XAddr) {\n\t\t\t\t\tthis.uri[name.toLowerCase()] = this._parseUrl(this.capabilities[name].XAddr);\n\t\t\t\t}\n\t\t\t}.bind(this));\n\t\t\t// extensions, eg. deviceIO\n\t\t\tif (this.capabilities.extension) {\n\t\t\t\tObject.keys(this.capabilities.extension).forEach(function(ext) {\n\t\t\t\t\t// TODO think about complex entensions like `telexCapabilities` and `scdlCapabilities`\n\t\t\t\t\tif (this.capabilities.extension[ext].XAddr) {\n\t\t\t\t\t\tthis.uri[ext] = url.parse(this.capabilities.extension[ext].XAddr);\n\t\t\t\t\t}\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t\t// HACK for a Profile G NVR that has 'replay' but did not have 'recording' in GetCapabilities\n\t\t\tif ((this.uri['replay']) && !this.uri['recording']) {\n\t\t\t\tvar tempRecorderXaddr = this.uri['replay'].href.replace('replay','recording');\n\t\t\t\tconsole.warn(\"WARNING: Adding \" + tempRecorderXaddr + \" for bad Profile G device\");\n\t\t\t\tthis.uri['recording'] = url.parse(tempRecorderXaddr);\n\t\t\t}\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.capabilities, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Returns the capabilities of the device service\n * @param [callback]\n */\nCam.prototype.getServiceCapabilities = function(callback) {\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<GetServiceCapabilities xmlns=\"http://www.onvif.org/ver10/device/wsdl\" />' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tdata = linerase(data);\n\t\t\tthis.serviceCapabilities = {\n\t\t\t\tnetwork: data.getServiceCapabilitiesResponse.capabilities.network.$\n\t\t\t\t, security: data.getServiceCapabilitiesResponse.capabilities.security.$\n\t\t\t\t, system: data.getServiceCapabilitiesResponse.capabilities.system.$\n\t\t\t};\n\t\t\tif (data.getServiceCapabilitiesResponse.capabilities.misc) {\n\t\t\t\tthis.serviceCapabilities.auxiliaryCommands = data.getServiceCapabilitiesResponse.capabilities.misc.$.AuxiliaryCommands.split(' ');\n\t\t\t}\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.serviceCapabilities, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Active source\n * @typedef {object} Cam~ActiveSource\n * @property {string} sourceToken video source token\n * @property {string} profileToken profile token\n * @property {object} [ptz] PTZ-object\n * @property {string} ptz.name PTZ configuration name\n * @property {string} ptz.token PTZ token\n */\n\n/**\n * Get active sources\n * @private\n */\nCam.prototype.getActiveSources = function() {\n\t//NVT is a camera with one video source\n\tif (this.videoSources.$) {\n\t\tthis.videoSources = [this.videoSources];\n\t}\n\n\t//The following code block supports a camera with a single video source\n\t//as well as encoders with multiple sources. By default, the first source is set to the activeSource.\n\t/**\n\t * Default profiles for the device\n\t * @name Cam#defaultProfiles\n\t * @type {Array.<Cam~Profile>}\n\t */\n\tthis.defaultProfiles = [];\n\t/**\n\t * Active video sources\n\t * @name Cam#activeSources\n\t * @type {Array.<Cam~ActiveSource>}\n\t */\n\tthis.activeSources = [];\n\n\tthis.videoSources.forEach(function(videoSource, idx) {\n\t\t// let's choose first appropriate profile for our video source and make it default\n\t\tvar videoSrcToken = videoSource.$.token\n\t\t\t, appropriateProfiles = this.profiles.filter(function(profile) {\n\t\t\t\treturn (profile.videoSourceConfiguration\n\t\t\t\t\t? profile.videoSourceConfiguration.sourceToken === videoSrcToken\n\t\t\t\t\t: false) && (profile.videoEncoderConfiguration);\n\t\t\t});\n\t\tif (appropriateProfiles.length === 0) {\n\t\t\tif (idx === 0) {\n\t\t\t\tthrow new Error('Unrecognized configuration');\n\t\t\t} else {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (idx === 0) {\n\t\t\t/**\n\t\t\t * Default selected profile for the device\n\t\t\t * @name Cam#defaultProfile\n\t\t\t * @type {Cam~Profile}\n\t\t\t */\n\t\t\tthis.defaultProfile = appropriateProfiles[0];\n\t\t}\n\n\t\tthis.defaultProfiles[idx] = appropriateProfiles[0];\n\n\t\tthis.activeSources[idx] = {\n\t\t\tsourceToken: videoSource.$.token\n\t\t\t, profileToken: this.defaultProfiles[idx].$.token\n\t\t\t, encoding: this.defaultProfiles[idx].videoEncoderConfiguration.encoding\n\t\t\t, width: this.defaultProfiles[idx].videoEncoderConfiguration.resolution.width\n\t\t\t, height: this.defaultProfiles[idx].videoEncoderConfiguration.resolution.height\n\t\t\t, fps: this.defaultProfiles[idx].videoEncoderConfiguration.rateControl.frameLimit\n\t\t\t, bitrate: this.defaultProfiles[idx].videoEncoderConfiguration.rateControl.bitrateLimit\n\t\t};\n\n\t\tif (idx === 0) {\n\t\t\t/**\n\t\t\t * Current active video source\n\t\t\t * @name Cam#activeSource\n\t\t\t * @type {Cam~ActiveSource}\n\t\t\t */\n\t\t\tthis.activeSource = this.activeSources[idx];\n\t\t}\n\n\t\tif (this.defaultProfiles[idx].PTZConfiguration) {\n\t\t\tthis.activeSources[idx].ptz = {\n\t\t\t\tname: this.defaultProfiles[idx].PTZConfiguration.name\n\t\t\t\t, token: this.defaultProfiles[idx].PTZConfiguration.$.token\n\t\t\t};\n\t\t\t/*\n\t\t\tTODO Think about it\n\t\t\tif (idx === 0) {\n\t\t\t\tthis.defaultProfile.PTZConfiguration = this.activeSources[idx].PTZConfiguration;\n\t\t\t}*/\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~Service\n * @property {string} namespace Namespace uri\n * @property {string} XAddr Uri for requests\n * @property {number} version.minor Minor version\n * @property {number} version.major Major version\n */\n\n/**\n * @callback Cam~GetServicesCallback\n * @property {?Error} error\n * @property {Array.<Cam~Service>} services\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive services\n * @param {Cam~GetServicesCallback} [callback]\n */\nCam.prototype.getServices = function(callback) {\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<GetServices xmlns=\"http://www.onvif.org/ver10/device/wsdl\"><IncludeCapability>true</IncludeCapability></GetServices>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\t/**\n\t\t\t * Supported services and their URLs\n\t\t\t * @type {Array.<Cam~Service>}\n\t\t\t */\n\t\t\tthis.services = linerase(data).getServicesResponse.service;\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.services, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~DeviceInformation\n * @property {string} manufacturer The manufactor of the device\n * @property {string} model The device model\n * @property {string} firmwareVersion The firmware version in the device\n * @property {string} serialNumber The serial number of the device\n * @property {string} hardwareId The hardware ID of the device\n */\n\n/**\n * @callback Cam~GetDeviceInformationCallback\n * @property {?Error} error\n * @property {Cam~DeviceInformation} deviceInformation Device information\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive device information\n * @param {Cam~GetDeviceInformationCallback} [callback]\n */\nCam.prototype.getDeviceInformation = function(callback) {\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<GetDeviceInformation xmlns=\"http://www.onvif.org/ver10/device/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.deviceInformation = linerase(data).getDeviceInformationResponse;\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.deviceInformation, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~HostnameInformation\n * @property {boolean} fromDHCP Indicates whether the hostname is obtained from DHCP or not\n * @property {string} [name] Indicates the hostname\n */\n\n/**\n * @callback Cam~GetHostnameCallback\n * @property {?Error} error\n * @property {Cam~HostnameInformation} hostnameInformation Hostname information\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive hostname information\n * @param {Cam~GetHostnameCallback} [callback]\n */\nCam.prototype.getHostname = function(callback) {\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<GetHostname xmlns=\"http://www.onvif.org/ver10/device/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).getHostnameResponse.hostnameInformation, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~Scope\n * @property {string} scopeDef Indicates if the scope is fixed or configurable\n * @property {string} scopeItem Scope item URI\n */\n\n/**\n * @callback Cam~getScopesCallback\n * @property {?Error} error\n * @property {Array<Cam~Scope>} scopes Scopes\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive the scope parameters of a device\n * @param {Cam~getScopesCallback} callback\n */\nCam.prototype.getScopes = function(callback) {\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<GetScopes xmlns=\"http://www.onvif.org/ver10/device/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\t/**\n\t\t\t * Device scopes\n\t\t\t * @type {undefined|Array<Cam~Scope>}\n\t\t\t */\n\t\t\tthis.scopes = linerase(data).getScopesResponse.scopes;\n\t\t\tif (this.scopes === undefined) {\n\t\t\t\tthis.scopes = [];\n\t\t\t} else if (!Array.isArray(this.scopes)) {\n\t\t\t\tthis.scopes = [this.scopes];\n\t\t\t}\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.scopes, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Set the scope parameters of a device\n * @param {Array<string>} scopes array of scope's uris\n * @param {Cam~getScopesCallback} callback\n */\nCam.prototype.setScopes = function(scopes, callback) {\n\tthis._request({\n\t\tbody: this._envelopeHeader() +\n\t\t'<SetScopes xmlns=\"http://www.onvif.org/ver10/device/wsdl\">' +\n\t\t\tscopes.map(function(uri) { return '<Scopes>' + uri + '</Scopes>'; }).join('') +\n\t\t'</SetScopes>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (err || linerase(data).setScopesResponse !== '') {\n\t\t\treturn callback(linerase(data).setScopesResponse !== '' ? new Error('Wrong `SetScopes` response') : err, data, xml);\n\t\t}\n\t\t// get new scopes from device\n\t\tthis.getScopes(callback);\n\t}.bind(this));\n};\n\n/**\n * /Device/ Reboot the device\n * @param {Cam~MessageCallback} callback\n */\nCam.prototype.systemReboot = function(callback) {\n\tthis._request({\n\t\tservice: 'deviceIO'\n\t\t, body: this._envelopeHeader() +\n\t\t\t'<SystemReboot xmlns=\"http://www.onvif.org/ver10/device/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, res, xml) {\n\t\tif (!err) {\n\t\t\tres = res[0].systemRebootResponse[0].message[0];\n\t\t}\n\t\tcallback.call(this, err, res, xml);\n\t});\n};\n\n/**\n * Generate arguments for digest auth\n * @return {{passdigest: *, nonce: (*|String), timestamp: string}}\n * @private\n */\nCam.prototype._passwordDigest = function() {\n\tvar timestamp = (new Date(Date.now() + (this.timeShift || 0))).toISOString();\n\tvar nonce = new Buffer(16);\n\tnonce.writeUIntLE(Math.ceil(Math.random() * 0x100000000), 0, 4);\n\tnonce.writeUIntLE(Math.ceil(Math.random() * 0x100000000), 4, 4);\n\tnonce.writeUIntLE(Math.ceil(Math.random() * 0x100000000), 8, 4);\n\tnonce.writeUIntLE(Math.ceil(Math.random() * 0x100000000), 12, 4);\n\tvar cryptoDigest = crypto.createHash('sha1');\n\tcryptoDigest.update(Buffer.concat([nonce, new Buffer(timestamp, 'ascii'), new Buffer(this.password, 'ascii')]));\n\tvar passdigest = cryptoDigest.digest('base64');\n\treturn {\n\t\tpassdigest: passdigest\n\t\t, nonce: new Buffer(nonce).toString('base64')\n\t\t, timestamp: timestamp\n\t};\n};\n\n/**\n * Envelope header for all SOAP messages\n * @property {boolean} [openHeader=false]\n * @returns {string}\n * @private\n */\nCam.prototype._envelopeHeader = function(openHeader) {\n\tvar header = '<s:Envelope xmlns:s=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:a=\"http://www.w3.org/2005/08/addressing\">' +\n\t\t\t'<s:Header>';\n\t// Only insert Security if there is a username and password\n\tif (this.username && this.password) {\n\t\tvar req = this._passwordDigest();\n\t\theader += '<Security s:mustUnderstand=\"1\" xmlns=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-secext-1.0.xsd\">' +\n\t\t\t'<UsernameToken>' +\n\t\t\t'<Username>' + this.username + '</Username>' +\n\t\t\t'<Password Type=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-username-token-profile-1.0#PasswordDigest\">' + req.passdigest + '</Password>' +\n\t\t\t'<Nonce EncodingType=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-soap-message-security-1.0#Base64Binary\">' + req.nonce + '</Nonce>' +\n\t\t\t'<Created xmlns=\"http://docs.oasis-open.org/wss/2004/01/oasis-200401-wss-wssecurity-utility-1.0.xsd\">' + req.timestamp + '</Created>' +\n\t\t\t'</UsernameToken>' +\n\t\t\t'</Security>';\n\t}\n\tif (!(openHeader !== undefined && openHeader)) {\n\t\theader += '</s:Header>' +\n\t\t\t'<s:Body xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">';\n\t}\n\treturn header;\n};\n\n/**\n * Envelope footer for all SOAP messages\n * @returns {string}\n * @private\n */\nCam.prototype._envelopeFooter = function() {\n\treturn '</s:Body>' +\n\t\t'</s:Envelope>';\n};\n\n/**\n * Parse url with an eye on `preserveAddress` property\n * @param {string} address\n * @returns {Url}\n * @private\n */\nCam.prototype._parseUrl = function(address) {\n\tconst parsedAddress = url.parse(address);\n\t// If host for service and default host dirrers, also if preserve address property set\n\t// we substitute host, hostname and port from settings\n\tif (this.preserveAddress && this.hostname !== parsedAddress.hostname) {\n\t\tparsedAddress.hostname = this.hostname;\n\t\tparsedAddress.host = this.hostname;\n\t\tparsedAddress.port = this.port;\n\t\tparsedAddress.href = address;\n\t}\n\treturn parsedAddress;\n};\n\nmodule.exports = {\n\tCam: Cam\n};\n\n// extending Camera prototype\nrequire('./device');\nrequire('./events');\nrequire('./media');\nrequire('./ptz');\nrequire('./imaging');\nrequire('./recording');\nrequire('./replay');\n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/utils.js":"/**\n * @namespace utils\n * @description Common utils module\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nconst xml2js = require('xml2js')\n\t, numberRE = /^-?([1-9]\\d*|0)(\\.\\d*)?$/\n\t, dateRE = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(.\\d+)?Z$/\n\t, prefixMatch = /(?!xmlns)^.*:/\n\t;\n\n/**\n * Parse SOAP object to pretty JS-object\n * @param {object} xml\n * @returns {object}\n */\nconst linerase = function(xml) {\n\tif (Array.isArray(xml)) {\n\t\tif (xml.length > 1) {\n\t\t\treturn xml.map(linerase);\n\t\t} else {\n\t\t\txml = xml[0];\n\t\t}\n\t}\n\tif (typeof xml === 'object') {\n\t\tvar obj = {};\n\t\tObject.keys(xml).forEach(function(key) {\n\t\t\tif (key === '$') {\n\t\t\t\tobj.$ = linerase(xml.$);\n\t\t\t} else {\n\t\t\t\tobj[key] = linerase(xml[key]);\n\t\t\t}\n\t\t});\n\t\treturn obj;\n\t} else {\n\t\tif (xml === 'true') { return true; }\n\t\tif (xml === 'false') { return false; }\n\t\tif (numberRE.test(xml)) { return parseFloat(xml); }\n\t\tif (dateRE.test(xml)) { return new Date(xml); }\n\t\treturn xml;\n\t}\n};\n\n/**\n * @callback ParseSOAPStringCallback\n * @property {?Error} error\n * @property {object} SOAP response\n * @property {string} raw XML\n */\n\n/**\n * Parse SOAP response\n * @param {string} xml\n * @param {ParseSOAPStringCallback} callback\n */\nconst parseSOAPString = function(xml, callback) {\n\t/* Filter out xml name spaces */\n\txml = xml.replace(/xmlns(.*?)=(\".*?\")/g,'');\n\n\txml2js.parseString(\n\t\txml\n\t\t, {\n\t\t\ttagNameProcessors: [function(str) {\n\t\t\t\tstr = str.replace(prefixMatch, '');\n\t\t\t\tvar secondLetter = str.charAt(1);\n\t\t\t\tif (secondLetter && secondLetter.toUpperCase() !== secondLetter) {\n\t\t\t\t\treturn str.charAt(0).toLowerCase() + str.slice(1);\n\t\t\t\t} else {\n\t\t\t\t\treturn str;\n\t\t\t\t}\n\t\t\t}]\n\t\t}\n\t\t, function(err, result) {\n\t\t\tif (!result || !result['envelope'] || !result['envelope']['body']) {\n\t\t\t\tcallback(new Error('Wrong ONVIF SOAP response'), null, xml);\n\t\t\t} else {\n\t\t\t\tif (!err && result['envelope']['body'][0]['fault']) {\n\t\t\t\t\terr = new Error(\n\t\t\t\t\t\t'ONVIF SOAP Fault: ' +\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tresult.envelope.body[0].fault[0].reason[0].text[0]._\n\t\t\t\t\t\t\t||\n\t\t\t\t\t\t\tJSON.stringify(linerase(result.envelope.body[0].fault[0].code[0]))\n\t\t\t\t\t\t) +\n\t\t\t\t\t\t(\n\t\t\t\t\t\t\tresult.envelope.body[0].fault[0].detail\n\t\t\t\t\t\t\t? ': ' + result.envelope.body[0].fault[0].detail[0].text[0]\n\t\t\t\t\t\t\t: ''\n\t\t\t\t\t\t)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\tcallback(err, result['envelope']['body'], xml);\n\t\t\t}\n\t\t});\n};\n\nconst s4 = function() {\n\treturn (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);\n};\n\n/**\n * Generate GUID\n * @returns {string}\n */\nconst guid = function() {\n\treturn (s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4());\n};\n\nmodule.exports = {\n\tlinerase: linerase\n\t, parseSOAPString: parseSOAPString\n\t, guid: guid\n};\n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/device.js":"/**\n * @namespace cam\n * @description Device section for Cam class\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nconst Cam = require('./cam').Cam\n\t, linerase = require('./utils').linerase\n\t;\n\n/**\n * @typedef {object} Cam~NTPInformation\n * @property {boolean} fromDHCP Indicates if NTP information is to be retrieved by using DHCP\n * @property {object} [NTPFromDHCP] List of NTP addresses retrieved by using DHCP\n * @property {object} [NTPManual] List of manually entered NTP addresses\n */\n\n/**\n * @callback Cam~NTPCallback\n * @property {?Error} error\n * @property {Cam~NTPInformation} NTP information object of current device's NTP manual\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive NTP information from cam\n * @param {Cam~NTPCallback} callback\n */\nCam.prototype.getNTP = function(callback) {\n\tthis._request({\n\t\tservice: 'device'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetNTP xmlns=\"http://www.onvif.org/ver10/device/wsdl\"/>' +\n\t\t'</s:Body>' +\n\t\t'</s:Envelope>'\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.NTP = linerase(data[0]['getNTPResponse'][0]['NTPInformation'][0]);\n\t\t}\n\t\tcallback.call(this, err, err ? null : this.NTP, xml);\n\t});\n};\n\n/**\n * Set the NTP settings on a device\n * @param {object} options\n * @param {boolean} options.fromDHCP Indicate if NTP address information is to be retrieved using DHCP\n * @param {string} [options.type] Network host type: IPv4, IPv6 or DNS.\n * @param {string} [options.ipv4Address] IPv4 address\n * @param {string} [options.ipv6Address] IPv6 address\n * @param {string} [options.dnsName] DNS name\n * @param {string} [options.extension]\n * @param {Cam~RequestCallback} [callback]\n */\nCam.prototype.setNTP = function(options, callback) {\n\tthis._request({\n\t\tservice: 'device'\n\t\t, body: this._envelopeHeader() +\n\t\t'<SetNTP xmlns=\"http://www.onvif.org/ver10/device/wsdl\">' +\n\t\t\t'<FromDHCP>' + options.fromDHCP + '</FromDHCP>' +\n\t\t\t( options.type ? '<NTPManual>' +\n\t\t\t\t'<Type>' + options.type + '</Type>' +\n\t\t\t\t( options.ipv4Address ? '<IPv4Address>' + options.ipv4Address + '</IPv4Address>' : '' ) +\n\t\t\t\t( options.ipv6Address ? '<IPv6Address>' + options.ipv6Address + '</IPv6Address>' : '' ) +\n\t\t\t\t( options.dnsName ? '<DNSname>' + options.dnsName + '</DNSname>' : '' ) +\n\t\t\t\t( options.extension ? '<Extension>' + options.extension + '</Extension>' : '' ) +\n\t\t\t'</NTPManual>' : '') +\n\t\t'</SetNTP>' +\n\t\tthis._envelopeFooter()\n\t}, callback.bind(this));\n};","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/events.js":"/**\n * @namespace cam\n * @description Events section for Cam class\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\n/**\n * @typedef {object} Cam~CreatePullPointSubscriptionResponse\n * @property {object} subscriptionReference\n * @property {string|object} subscriptionReference.address\n * @property {Date} currentTime\n * @property {Date} terminationTime\n */\n\n/**\n * Events namespace for the device, stores all information about device events\n * @name Cam#events\n * @type object\n * @property {Cam~EventProperties} properties\n * @property {Cam~CreatePullPointSubscriptionResponse} subscription\n * @property {Date} terminationTime Time when pull-point subscription is over\n * @property {number} messageLimit Pull message count\n */\n\nconst Cam = require('./cam').Cam\n\t, cam = require('./cam')\n\t, linerase = require('./utils').linerase\n\t, url = require('url')\n\t;\n\n/**\n * Event properties object\n * @typedef {object} Cam~EventProperties\n * @property {array} topicNamespaceLocation\n * @property {object} topicSet\n * @property {array} topicExpressionDialect\n */\n\n/**\n * @callback Cam~GetEventPropertiesCallback\n * @property {?Error} err\n * @property {Cam~EventProperties} response\n * @property {string} response xml\n */\n\n/**\n * Get event properties of the device. Sets `events` property of the device\n * @param {Cam~GetEventPropertiesCallback} callback\n */\nCam.prototype.getEventProperties = function(callback) {\n\tthis._request({\n\t\tservice: 'events'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetEventProperties xmlns=\"http://www.onvif.org/ver10/events/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, res, xml) {\n\t\tif (!err) {\n\t\t\tthis.events.properties = linerase(res).getEventPropertiesResponse;\n\t\t}\n\t\tcallback.call(this, err, err ? null : this.events.properties, xml);\n\t}.bind(this));\n};\n\n/**\n * Get event service capabilities\n * @param {function} callback\n */\nCam.prototype.getEventServiceCapabilities = function(callback) {\n\tthis._request({\n\t\tservice: 'events'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetServiceCapabilities xmlns=\"http://www.onvif.org/ver10/events/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, res, xml) {\n\t\tif (!err) {\n\t\t\tvar data = linerase(res[0].getServiceCapabilitiesResponse[0].capabilities[0].$);\n\t\t}\n\t\tcallback.call(this, err, data, xml);\n\t}.bind(this));\n};\n\n/**\n * Create pull-point subscription\n * @param {function} callback\n */\nCam.prototype.createPullPointSubscription = function(callback) {\n\tthis._request({\n\t\tservice: 'events'\n\t\t, body: this._envelopeHeader() +\n\t\t'<CreatePullPointSubscription xmlns=\"http://www.onvif.org/ver10/events/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, res, xml) {\n\t\tif (!err) {\n\t\t\tthis.events.subscription = linerase(res[0].createPullPointSubscriptionResponse[0]);\n\t\t\tthis.events.subscription.subscriptionReference.address =\n\t\t\t\tthis._parseUrl(this.events.subscription.subscriptionReference.address);\n\t\t\tthis.events.terminationTime = _terminationTime(this.events.subscription);\n\t\t}\n\t\tcallback.call(this, err, err ? null : this.events.subscription, xml);\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~Event\n * @property {Date} currentTime\n * @property {Date} terminationTime\n * @property {Cam~NotificationMessage|Array.<Cam~NotificationMessage>} [notificationMessage]\n */\n\n/**\n * @typedef {object} Cam~NotificationMessage\n * @property {string} subscriptionReference.address Pull-point address\n * @property {string} topic._ Namespace of message topic\n * @property {object} message Message object\n */\n\n/**\n * @callback Cam~PullMessagesResponse\n * @property {?Error} error\n * @property {Cam~Event} response Message\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Pull messages from pull-point subscription\n * @param options\n * @param {number} [options.timeout=30000]\n * @param {number} [options.messageLimit=1]\n * @param {Cam~PullMessagesResponse} callback\n * @throws {Error} {@link Cam#events.subscription} must exists\n */\nCam.prototype.pullMessages = function(options, callback) {\n\ttry {\n\t\tvar urlAddress = this.events.subscription.subscriptionReference.address;\n\t} catch (e) {\n\t\tthrow new Error('You should create pull-point subscription first!');\n\t}\n\tthis._request({\n\t\turl: urlAddress\n\t\t, body: this._envelopeHeader() +\n\t\t'<PullMessages xmlns=\"http://www.onvif.org/ver10/events/wsdl\">' +\n\t\t\t'<Timeout>PT' + ((options.timeout || 30000) / 1000) + 'S</Timeout>' +\n\t\t\t'<MessageLimit>' + (options.messageLimit || 1) + '</MessageLimit>' +\n\t\t'</PullMessages>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, res, xml) {\n\t\tif (!err) {\n\t\t\tvar data = linerase(res).pullMessagesResponse;\n\t\t}\n\t\tcallback.call(this, err, data, xml);\n\t}.bind(this));\n};\n\n/**\n * Count time before pull-point subscription terminates\n * @param {Cam~CreatePullPointSubscriptionResponse} response\n * @returns {Date}\n * @private\n */\nfunction _terminationTime(response) {\n\treturn new Date(Date.now() - response.currentTime.getTime() + response.terminationTime.getTime());\n}\n\n/**\n * Bind event handling to the `event` event\n */\nCam.prototype.on('newListener', function(name) {\n\t// if there is the first listener, start pulling\n\tif (name === 'event' && this.listeners(name).length === 0) {\n\t\tthis._eventRequest();\n\t}\n});\n\n/**\n * Event loop for pullMessages request\n * @private\n */\nCam.prototype._eventRequest = function() {\n\tthis.events.timeout = this.events.timeout || 30000; // setting timeout\n\tthis.events.messageLimit = this.events.messageLimit || 1; // setting message limit\n\tif (!this.events.terminationTime || (this.events.terminationTime < Date.now() + this.events.timeout)) {\n\t\t// if there is no pull-point subscription or it will be dead soon, create new\n\t\tthis.createPullPointSubscription(this._eventPull.bind(this));\n\t} else {\n\t\tthis._eventPull();\n\t}\n};\n\n/**\n * Event loop for pullMessages request\n * @private\n */\nCam.prototype._eventPull = function() {\n\tif (this.listeners('event').length) { // check for event listeners, if zero, stop pulling\n\t\tthis.pullMessages({\n\t\t\ttimeout: this.events.timeout\n\t\t\t, messageLimit: this.events.messageLimit\n\t\t}, function(err, data) {\n\t\t\tif (!err) {\n\t\t\t\tif (data.notificationMessage) {\n\t\t\t\t\tif (!Array.isArray(data.notificationMessage)) {\n\t\t\t\t\t\tdata.notificationMessage = [data.notificationMessage];\n\t\t\t\t\t}\n\t\t\t\t\tdata.notificationMessage.forEach(function(message) {\n\t\t\t\t\t\t// pull-point address check\n\t\t\t\t\t\tif (message.subscriptionReference.address === this.events.subscription.subscriptionReference.address.href) {\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * Indicates message from device.\n\t\t\t\t\t\t\t * @event Cam#event\n\t\t\t\t\t\t\t * @type {Cam~NotificationMessage}\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tthis.emit('event', message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}.bind(this));\n\t\t\t\t}\n\t\t\t\tthis.events.terminationTime = _terminationTime(data);\n\t\t\t}\n\t\t\tthis._eventRequest();\n\t\t}.bind(this));\n\t}\n};","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/media.js":"/**\n * @namespace cam\n * @description Media section for Cam class\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nconst Cam = require('./cam').Cam\n\t, linerase = require('./utils').linerase\n\t;\n\n/**\n * @typedef {object} Cam~VideoSource\n * @property {string} $.token Video source token\n * @property {number} framerate\n * @property {number} resolution.width\n * @property {number} resolution.height\n */\n\n/**\n * @callback Cam~GetVideoSourcesCallback\n * @property {?Error} error\n * @property {Cam~VideoSource|Array.<Cam~VideoSource>} videoSources\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive video sources\n * @param {Cam~GetVideoSourcesCallback} [callback]\n */\nCam.prototype.getVideoSources = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetVideoSources xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\t/**\n\t\t\t * Video sources\n\t\t\t * @name Cam#videoSources\n\t\t\t * @type {Cam~VideoSource|Array.<Cam~VideoSource>}\n\t\t\t */\n\t\t\tthis.videoSources = linerase(data).getVideoSourcesResponse.videoSources;\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.videoSources, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~VideoSourceConfiguration\n * @property {string} token Token that uniquely refernces this configuration\n * @property {string} sourceToken Reference to the physical input\n * @property {string} name User readable name\n * @property {number} useCount Number of internal references currently using this configuration\n * @property {object} bounds\n * @property {number} bounds.height\n * @property {number} bounds.width\n * @property {number} bounds.x\n * @property {number} bounds.y\n */\n\n/**\n * @callback Cam~GetVideoSourceConfigurationsCallback\n * @property {?Error} error\n * @property {Array.<Cam~VideoSourceConfiguration>} videoSourceConfigurations\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Receive video sources\n * @param {Cam~GetVideoSourceConfigurationsCallback} [callback]\n */\nCam.prototype.getVideoSourceConfigurations = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetVideoSourceConfigurations xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.videoSourceConfigurations = data[0].getVideoSourceConfigurationsResponse[0].configurations.map(function(data) {\n\t\t\t\tvar obj =  linerase(data);\n\t\t\t\treturn {\n\t\t\t\t\ttoken: obj.$.token\n\t\t\t\t\t, name: obj.name\n\t\t\t\t\t, useCount: obj.useCount\n\t\t\t\t\t, sourceToken: obj.sourceToken\n\t\t\t\t\t, bounds: {\n\t\t\t\t\t\theight: obj.bounds.$.height\n\t\t\t\t\t\t, width: obj.bounds.$.width\n\t\t\t\t\t\t, x: obj.bounds.$.x\n\t\t\t\t\t\t, y: obj.bounds.$.y\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.videoSourceConfigurations, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~VideoEncoderConfiguration\n * @property {string} $.token Token that uniquely refernces this configuration\n * @property {string} name User readable name.\n * @property {string} useCount Number of internal references currently using this configuration\n * @property {string} encoding Used video codec ('JPEG' | 'MPEG4' | 'H264' )\n * @property {object} resolution Configured video resolution\n * @property {number} resolution.width\n * @property {number} resolution.height\n * @property {number} quality Relative value for the video quantizers and the quality of the video. A high value within supported quality range means higher quality\n * @property {object} [rateControl] Optional element to configure rate control related parameters\n * @property {number} rateControl.frameRateLimit\n * @property {number} rateControl.encodingInterval\n * @property {number} rateControl.bitrateLimit\n * @property {object} [H264] Optional element to configure H.264 related parameters\n * @property {number} H264.govLength Group of Video frames length\n * @property {string} H264.H264profile the H.264 profile\n * @property {object} [MPEG4] Optional element to configure Mpeg4 related parameters\n * @property {number} MPEG4.govLength Determines the interval in which the I-Frames will be coded.\n * @property {string} MPEG4.MPEG4profile the Mpeg4 profile\n * @property {object} multicast\n * @property {string} multicast.address.type\n * @property {string} [multicast.address.IPv4Address]\n * @property {string} [multicast.address.IPv6Address]\n * @property {number} multicast.port\n * @property {number} multicast.TTL\n * @property {boolean} multicast.autoStart\n * @property {string} sessionTimeout The rtsp session timeout for the related video stream\n */\n\n/**\n * @callback Cam~VideoEncoderConfigurationCallback\n * @property {?Error} error\n * @property {Cam~VideoEncoderConfiguration} videoEncoderConfiguration\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * @callback Cam~VideoEncoderConfigurationsCallback\n * @property {?Error} error\n * @property {Array.<Cam~VideoEncoderConfiguration>} videoEncoderConfigurations\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Get existing video encoder configuration by its token\n * If token is omitted tries first from #videoEncoderConfigurations array\n * @param {string} [token] Token of the requested video encoder configuration\n * @param {Cam~VideoEncoderConfigurationCallback} callback\n */\nCam.prototype.getVideoEncoderConfiguration = function(token, callback) {\n\tif (callback === undefined) {\n\t\tcallback = token;\n\t\tif (this.videoEncoderConfigurations && this.videoEncoderConfigurations[0]) {\n\t\t\ttoken = this.videoEncoderConfigurations[0].$.token;\n\t\t} else {\n\t\t\treturn callback(new Error('No video encoder configuration token is present!'));\n\t\t}\n\t}\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetVideoEncoderConfiguration xmlns=\"http://www.onvif.org/ver10/media/wsdl\">' +\n\t\t\t'<ConfigurationToken>' + token + '</ConfigurationToken>' +\n\t\t'</GetVideoEncoderConfiguration>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data[0].getVideoEncoderConfigurationResponse[0].configuration), xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~VideoEncoderConfigurationOptions\n * @property {object} qualityRange Range of the quality values. A high value means higher quality\n * @property {number} qualityRange.min\n * @property {number} qualityRange.max\n * @property {object} [JPEG] Optional JPEG encoder settings ranges\n * @property {object} JPEG.resolutionsAvailable List of supported resolutions\n * @property {number} JPEG.resolutionsAvailable.width\n * @property {number} JPEG.resolutionsAvailable.height\n * @property {object} JPEG.frameRateRange Range of frame rate settings\n * @property {number} JPEG.frameRateRange.min\n * @property {number} JPEG.frameRateRange.max\n * @property {object} JPEG.encodingIntervalRange Range of encoding interval settings\n * @property {number} JPEG.encodingInterval.min\n * @property {number} JPEG.encodingInterval.max\n * @property {object} [MPEG4] Optional MPEG4 encoder settings ranges\n * @property {object} MPEG4.resolutionsAvailable List of supported resolutions\n * @property {number} MPEG4.resolutionsAvailable.width\n * @property {number} MPEG4.resolutionsAvailable.height\n * @property {object} MPEG4.resolutionsAvailable List of supported resolutions\n * @property {object} MPEG4.frameRateRange Range of frame rate settings\n * @property {number} MPEG4.frameRateRange.min\n * @property {number} MPEG4.frameRateRange.max\n * @property {object} MPEG4.encodingIntervalRange Range of encoding interval settings\n * @property {number} MPEG4.encodingInterval.min\n * @property {number} MPEG4.encodingInterval.max\n * @property {object} MPEG4.govLengthRange Range of group of video frames length settings\n * @property {number} MPEG4.govLengthRange.min\n * @property {number} MPEG4.govLengthRange.max\n * @property {object} MPEG4.MPEG4ProfilesSupported List of supported MPEG4 profiles enum {'SP', 'ASP'}\n * @property {object} [H264] Optional H.264 encoder settings ranges\n * @property {object} H264.resolutionsAvailable List of supported resolutions\n * @property {number} H264.resolutionsAvailable.width\n * @property {number} H264.resolutionsAvailable.height\n * @property {object} H264.frameRateRange Range of frame rate settings\n * @property {number} H264.frameRateRange.min\n * @property {number} H264.frameRateRange.max\n * @property {object} H264.encodingIntervalRange Range of encoding interval settings\n * @property {number} H264.encodingInterval.min\n * @property {number} H264.encodingInterval.max\n * @property {object} H264.govLengthRange Range of group of video frames length settings\n * @property {number} H264.govLengthRange.min\n * @property {number} H264.govLengthRange.max\n * @property {object} H264.H264ProfilesSupported List of supported H.264 profiles enum {'Baseline', 'Main', 'Extended', 'High'}\n * @property {object} [extension] Optional encoder extensions\n * @property {object} [extension.JPEG] Optional JPEG encoder settings ranges\n * @property {object} extension.JPEG.resolutionsAvailable List of supported resolutions\n * @property {number} extension.JPEG.resolutionsAvailable.width\n * @property {number} extension.JPEG.resolutionsAvailable.height\n * @property {object} extension.JPEG.frameRateRange Range of frame rate settings\n * @property {number} extension.JPEG.frameRateRange.min\n * @property {number} extension.JPEG.frameRateRange.max\n * @property {object} extension.JPEG.encodingIntervalRange Range of encoding interval settings\n * @property {number} extension.JPEG.encodingInterval.min\n * @property {number} extension.JPEG.encodingInterval.max\n * @property {object} extension.JPEG.bitrateRange Range of bitrate settings\n * @property {number} extension.JPEG.bitrateRange.min\n * @property {number} extension.JPEG.bitrateRange.max\n * @property {object} [extension.MPEG4] Optional MPEG4 encoder settings ranges\n * @property {object} extension.MPEG4.resolutionsAvailable List of supported resolutions\n * @property {number} extension.MPEG4.resolutionsAvailable.width\n * @property {number} extension.MPEG4.resolutionsAvailable.height\n * @property {object} extension.MPEG4.resolutionsAvailable List of supported resolutions\n * @property {object} extension.MPEG4.frameRateRange Range of frame rate settings\n * @property {number} extension.MPEG4.frameRateRange.min\n * @property {number} extension.MPEG4.frameRateRange.max\n * @property {object} extension.MPEG4.encodingIntervalRange Range of encoding interval settings\n * @property {number} extension.MPEG4.encodingInterval.min\n * @property {number} extension.MPEG4.encodingInterval.max\n * @property {object} extension.MPEG4.govLengthRange Range of group of video frames length settings\n * @property {number} extension.MPEG4.govLengthRange.min\n * @property {number} extension.MPEG4.govLengthRange.max\n * @property {object} extension.MPEG4.MPEG4ProfilesSupported List of supported MPEG4 profiles enum {'SP', 'ASP'}\n * @property {object} extension.MPEG4.bitrateRange Range of bitrate settings\n * @property {number} extension.MPEG4.bitrateRange.min\n * @property {number} extension.MPEG4.bitrateRange.max\n * @property {object} [extension.H264] Optional H.264 encoder settings ranges\n * @property {object} extension.H264.resolutionsAvailable List of supported resolutions\n * @property {number} extension.H264.resolutionsAvailable.width\n * @property {number} extension.H264.resolutionsAvailable.height\n * @property {object} extension.H264.frameRateRange Range of frame rate settings\n * @property {number} extension.H264.frameRateRange.min\n * @property {number} extension.H264.frameRateRange.max\n * @property {object} extension.H264.encodingIntervalRange Range of encoding interval settings\n * @property {number} extension.H264.encodingInterval.min\n * @property {number} extension.H264.encodingInterval.max\n * @property {object} extension.H264.govLengthRange Range of group of video frames length settings\n * @property {number} extension.H264.govLengthRange.min\n * @property {number} extension.H264.govLengthRange.max\n * @property {object} extension.H264.H264ProfilesSupported List of supported H.264 profiles enum {'Baseline', 'Main', 'Extended', 'High'}\n * @property {object} extension.H264.bitrateRange Range of bitrate settings\n * @property {number} extension.H264.bitrateRange.min\n * @property {number} extension.H264.bitrateRange.max\n * @property {object} [extension.extension] Even more optional extensions\n */\n\n/**\n * @callback Cam~VideoEncoderConfigurationOptionsCallback\n * @property {?Error} error\n * @property {Cam~VideoEncoderConfigurationOptions} videoEncoderConfigurationOptions\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Get existing video encoder configuration options by its token\n * If token is omitted tries first from #videoEncoderConfigurations array\n * @param {string} [token] Token of the requested video encoder configuration\n * @param {Cam~VideoEncoderConfigurationOptionsCallback} callback\n */\nCam.prototype.getVideoEncoderConfigurationOptions = function(token, callback) {\n\tif (callback === undefined) {\n\t\tcallback = token;\n\t\tif (this.videoEncoderConfigurations && this.videoEncoderConfigurations[0]) {\n\t\t\ttoken = this.videoEncoderConfigurations[0].$.token;\n\t\t} else {\n\t\t\treturn callback(new Error('No video encoder configuration token is present!'));\n\t\t}\n\t}\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetVideoEncoderConfigurationOptions xmlns=\"http://www.onvif.org/ver10/media/wsdl\">' +\n\t\t\t'<ConfigurationToken>' + token + '</ConfigurationToken>' +\n\t\t'</GetVideoEncoderConfigurationOptions>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data[0].getVideoEncoderConfigurationOptionsResponse[0].options), xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Get all existing video encoder configurations of a device\n * @param {Cam~VideoEncoderConfigurationsCallback} callback\n */\nCam.prototype.getVideoEncoderConfigurations = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetVideoEncoderConfigurations xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.videoEncoderConfigurations = data[0].getVideoEncoderConfigurationsResponse[0].configurations.map(function(config) {\n\t\t\t\treturn linerase(config);\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.videoEncoderConfigurations, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Set the device video encoder configuration\n * @param {object} options\n * @param {string} [options.token] Token that uniquely references this configuration.\n * @param {string} [options.$.token] Token that uniquely references this configuration.\n * @param {string} [options.name] User readable name.\n * @param {number} [options.useCount] Number of internal references (read-only)\n * @param {string} [options.encoding] ( JPEG | H264 | MPEG4 )\n * @param {object} [options.resolution] Configured video resolution\n * @param {number} options.resolution.width Number of the columns of the Video image\n * @param {number} options.resolution.height Number of the lines of the Video image\n * @param {number} options.quality Relative value for the video quantizers and the quality of the video\n * @param {object} [options.rateControl] Optional element to configure rate control related parameters\n * @param {number} options.rateControl.frameRateLimit Maximum output framerate in fps\n * @param {number} options.rateControl.encodingInterval Interval at which images are encoded and transmitted  (A value of 1 means that every frame is encoded, a value of 2 means that every 2nd frame is encoded ...)\n * @param {number} options.rateControl.bitrateLimit the maximum output bitrate in kbps\n * @param {object} [options.MPEG4]\n * @param {number} options.MPEG4.govLength Determines the interval in which the I-Frames will be coded\n * @param {string} options.MPEG4.profile the Mpeg4 profile ( SP | ASP )\n * @param {object} [options.H264]\n * @param {number} options.H264.govLength Group of Video frames length\n * @param {string} options.H264.profile the H.264 profile ( Baseline | Main | Extended | High )\n * @param {object} [options.multicast]\n * @param {object|number} [options.multicast.address] The multicast address (if this address is set to 0 no multicast streaming is enaled)\n * @param {string} options.multicast.address.type Indicates if the address is an IPv4 or IPv6 address ( IPv4 | IPv6)\n * @param {string} [options.multicast.address.IPv4Address]\n * @param {string} [options.multicast.address.IPv6Address]\n * @param {number} [options.multicast.port] The RTP mutlicast destination port\n * @param {number} [options.multicast.TTL]\n * @param {boolean} [options.multicast.autoStart]\n * @param {string} options.sessionTimeout\n * @param {Cam~VideoEncoderConfigurationCallback} callback\n */\nCam.prototype.setVideoEncoderConfiguration = function(options, callback) {\n\tif (!options.token && !(options.$ && options.$.token)) {\n\t\treturn callback(new Error('No video encoder configuration token is present!'));\n\t}\n\tthis._request({\n\t\tservice: 'media', \n\t\tbody: this._envelopeHeader() +\n\t\t'<SetVideoEncoderConfiguration xmlns=\"http://www.onvif.org/ver10/media/wsdl\">' +\n\t\t\t'<Configuration token = \"' + (options.token || options.$.token) + '\">' +\n\t\t\t( options.name ? '<Name xmlns=\"http://www.onvif.org/ver10/schema\">' + options.name + '</Name>' : '' ) +\n\t\t\t( options.useCount ? '<UseCount xmlns=\"http://www.onvif.org/ver10/schema\">' + options.useCount + '</UseCount>' : '' ) +\n\t\t\t( options.encoding ? '<Encoding xmlns=\"http://www.onvif.org/ver10/schema\">' + options.encoding + '</Encoding>' : '' ) +\n\t\t\t( options.resolution ?\n\t\t\t'<Resolution xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t( options.resolution.width ? '<Width>' + options.resolution.width + '</Width>' : '') +\n\t\t\t\t( options.resolution.height ? '<Height>' + options.resolution.height + '</Height>' : '') +\n\t\t\t'</Resolution>' : '') +\n\t\t\t( options.quality ? '<Quality xmlns=\"http://www.onvif.org/ver10/schema\">' + options.quality + '</Quality>' : '' ) +\n\t\t\t( options.rateControl ?\n\t\t\t'<RateControl xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t( options.rateControl.frameRateLimit ? '<FrameRateLimit>' + options.rateControl.frameRateLimit + '</FrameRateLimit>' : '' ) +\n\t\t\t\t( options.rateControl.encodingInterval ? '<EncodingInterval>' + options.rateControl.encodingInterval + '</EncodingInterval>' : '' ) +\n\t\t\t\t( options.rateControl.bitrateLimit ? '<BitrateLimit>' + options.rateControl.bitrateLimit + '</BitrateLimit>' : '' ) +\n\t\t\t'</RateControl>' : '' ) +\n\t\t\t( options.MPEG4 ?\n\t\t\t'<MPEG4 xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t( options.MPEG4.govLength ? '<GovLength>' + options.MPEG4.govLength + '</GovLength>' : '' ) +\n\t\t\t\t( options.MPEG4.profile ? '<MPEG4Profile>' + options.MPEG4.profile + '</MPEG4Profile>' : '') +\n\t\t\t'</MPEG4>' : '') +\n\t\t\t( options.H264 ? '<H264 xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t( options.H264.govLength ? '<GovLength>' + options.H264.govLength + '</GovLength>' : '' ) +\n\t\t\t\t( options.H264.profile ? '<H264Profile>' + options.H264.profile + '</H264Profile>' : '' ) +\n\t\t\t'</H264>' : '') +\n\t\t\t( options.multicast ?\n\t\t\t'<Multicast xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t( options.multicast.address ?\n\t\t\t\t'<Address>' +\n\t\t\t\t\t( options.multicast.address === 0 ? '0' :\n\t\t\t\t\t\t( options.multicast.address.type ? '<Type>' + options.multicast.address.type + '</Type>' : '' ) +\n\t\t\t\t\t\t( options.multicast.address.IPv4Address ? '<IPv4Address>' + options.multicast.address.IPv4Address + '</IPv4Address>' : '') +\n\t\t\t\t\t\t( options.multicast.address.IPv6Address ? '<IPv6Address>' + options.multicast.address.IPv6Address + '</IPv6Address>' : '')\n\t\t\t\t\t) +\n\t\t\t\t'</Address>' : '') +\n\t\t\t\t( options.multicast.port !== undefined ? '<Port>' + options.multicast.port + '</Port>' : '' ) +\n\t\t\t\t( options.multicast.TTL !== undefined ? '<TTL>' + options.multicast.TTL + '</TTL>' : '') +\n\t\t\t\t( options.multicast.autoStart !== undefined ? '<AutoStart>' + options.multicast.autoStart + '</AutoStart>' : '') +\n\t\t\t'</Multicast>' : '' ) +\n\t\t\t( options.sessionTimeout ?\n\t\t\t'<SessionTimeout xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\toptions.sessionTimeout +\n\t\t\t'</SessionTimeout>' : '' ) +\n\t\t\t'</Configuration>' +\n\t\t\t'<ForcePersistence>true</ForcePersistence>' +\n\t\t'</SetVideoEncoderConfiguration>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (err || linerase(data).setVideoEncoderConfigurationResponse !== '') {\n\t\t\treturn callback.call(this, linerase(data).setVideoEncoderConfigurationResponse !== ''\n\t\t\t\t? new Error('Wrong `SetVideoEncoderConfiguration` response')\n\t\t\t\t: err, data, xml);\n\t\t}\n\t\t//get new encoding settings from device\n\t\tthis.getVideoEncoderConfiguration(options.token || options.$.token, callback);\n\t}.bind(this));\n};\n\n/**\n * Get all available physical audio iutputs  of a device\n * @param callback\n */\nCam.prototype.getAudioSources = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetAudioSources xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.audioSources = data[0].getAudioSourcesResponse[0].audioSources.map(function(config) {\n\t\t\t\treturn linerase(config);\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.audioSources, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Get all available audio encoder configurations of a device\n * @param callback\n */\nCam.prototype.getAudioEncoderConfigurations = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetAudioEncoderConfigurations xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.audioEncoderConfigurations = data[0].getAudioEncoderConfigurationsResponse[0].configurations.map(function(config) {\n\t\t\t\treturn linerase(config);\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.audioEncoderConfigurations, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Get all existing audio source configurations of a device\n * @param callback\n */\nCam.prototype.getAudioSourceConfigurations = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetAudioSourceConfigurations xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.audioSourceConfigurations = data[0].getAudioSourceConfigurationsResponse[0].configurations.map(function(config) {\n\t\t\t\treturn linerase(config);\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.audioSourceConfigurations, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Get all available audio outputs  of a device\n * @param callback\n */\nCam.prototype.getAudioOutputs = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetAudioOutputs xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.audioOutputs = data[0].getAudioOutputsResponse[0].audioOutputs.map(function(config) {\n\t\t\t\treturn linerase(config);\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.audioOutputs, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Get all existing audio output configurations of a device\n * @param callback\n */\nCam.prototype.getAudioOutputConfigurations = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetAudioOutputConfigurations xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.audioOutputConfigurations = data[0].getAudioOutputConfigurationsResponse[0].configurations.map(function(config) {\n\t\t\t\treturn linerase(config);\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.audioOutputConfigurations, xml);\n\t\t}\n\t}.bind(this));\n};\n\n// TODO AddVideoEncoderConfiguration\n\n/*\n Cam.prototype.getVideoEncoderConfigurationOptions = function(options, callback) {\n if (callback === undefined) {callback = options; options = {};}\n this._request({\n service: 'media'\n , body: this._envelopeHeader() +\n '<GetVideoEncoderConfigurationOptions xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n this._envelopeFooter()\n }, function(err, data, xml) {\n if (!err) {\n }\n if (callback) {\n callback.call(this, err, this.videoEncoderConfigurations, xml);\n }\n }.bind(this));\n };\n */\n\n/**\n * @typedef {object} Cam~Profile\n * @property {object} $\n * @property {string} $.token profile token\n * @property {boolean} $.fixed is this a system or a user profile\n * @property {object} videoSourceConfiguration\n * @property {string} videoSourceConfiguration.$.token video source token\n * @property {object} videoEncoderConfiguration\n * @property {object} PTZConfiguration\n * @property {string} PTZConfiguration.$.token PTZ token\n * @property {string} PTZConfiguration.name PTZ configuration name\n */\n\n/**\n * @callback Cam~GetProfilesCallback\n * @property {?Error} error\n * @property {Array.<Cam~Profile>} profiles Array of device's profiles\n * @property {string} xml Raw XML response\n */\n\n/**\n * /Media/ Receive profiles\n * @param {Cam~GetProfilesCallback} [callback]\n */\nCam.prototype.getProfiles = function(callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetProfiles xmlns=\"http://www.onvif.org/ver10/media/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\t/**\n\t\t\t * Array of all device profiles\n\t\t\t * @name Cam#profiles\n\t\t\t * @type {Array<Cam~Profile>}\n\t\t\t */\n\t\t\tthis.profiles = data[0]['getProfilesResponse'][0]['profiles'].map(function(profile) {\n\t\t\t\treturn linerase(profile);\n\t\t\t});\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.profiles, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Create an empty new deletable media profile\n * @param options\n * @param {string} options.name Profile name\n * @param {string} [options.token] Profile token\n * @param {Cam~MessageCallback} callback\n */\nCam.prototype.createProfile = function(options, callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<CreateProfile xmlns=\"http://www.onvif.org/ver10/media/wsdl\">' +\n\t\t\t'<Name>' + options.name + '</Name>' +\n\t\t\t( options.token ? '<Token>' + options.token + '</Token>' : '' ) +\n\t\t'</CreateProfile>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).createProfileResponse.profile, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Delete a profile\n * @param {string} token\n * @param {Cam~MessageCallback} callback\n */\nCam.prototype.deleteProfile = function(token, callback) {\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<DeleteProfile xmlns=\"http://www.onvif.org/ver10/media/wsdl\">' +\n\t\t\t'<ProfileToken>' + token + '</ProfileToken>' +\n\t\t'</DeleteProfile>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).deleteProfileResponse, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @callback Cam~ResponseUriCallback\n * @property {string} uri\n */\n\n/**\n * Receive stream URI\n * @param {Object} [options]\n * @param {string} [options.stream]\n * @param {string} [options.protocol]\n * @param {string} [options.profileToken]\n * @param {Cam~ResponseUriCallback} [callback]\n */\nCam.prototype.getStreamUri = function(options, callback) {\n\tif (callback === undefined) { callback = options; options = {};\t}\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetStreamUri xmlns=\"http://www.onvif.org/ver10/media/wsdl\">' +\n\t\t\t'<StreamSetup>' +\n\t\t\t\t'<Stream xmlns=\"http://www.onvif.org/ver10/schema\">' + (options.stream || 'RTP-Unicast') +'</Stream>' +\n\t\t\t\t'<Transport xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t'<Protocol>' + (options.protocol || 'RTSP') +'</Protocol>' +\n\t\t\t\t'</Transport>' +\n\t\t\t'</StreamSetup>' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) +'</ProfileToken>' +\n\t\t'</GetStreamUri>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).getStreamUriResponse.mediaUri, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Receive snapshot URI\n * @param {Object} [options]\n * @param {string} [options.profileToken]\n * @param {Cam~ResponseUriCallback} [callback]\n */\nCam.prototype.getSnapshotUri = function(options, callback) {\n\tif (callback === undefined) { callback = options; options = {}; }\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetSnapshotUri xmlns=\"http://www.onvif.org/ver10/media/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) +'</ProfileToken>' +\n\t\t'</GetSnapshotUri>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).getSnapshotUriResponse.mediaUri, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Get the OSDs.\n * @param {string} [token] Token of the Video Source Configuration, which has OSDs associated with are requested.\n * If token not exist, request all available OSDs.\n * @param {Cam~GetOSDsCallback} callback\n */\nCam.prototype.getOSDs = function(token, callback) {\n\tif (callback === undefined) { callback = token; token = ''; }\n\tthis._request({\n\t\tservice: 'media'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetOSDs xmlns=\"http://www.onvif.org/ver10/media/wsdl\" >' +\n\t\t\t(token ? '<ConfigurationToken>' + token + '</ConfigurationToken>' : '') +\n\t\t'</GetOSDs>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data), xml);\n\t\t}\n\t}.bind(this));\n};\n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/ptz.js":"/**\n * @namespace cam\n * @description PTZ section for Cam class\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nconst Cam = require('./cam').Cam\n\t, extend = require('util')._extend\n\t, linerase = require('./utils').linerase\n\t, url = require('url')\n\t;\n\n/**\n * Receive cam presets\n * @param {object} [options]\n * @param {string} [options.profileToken]\n * @param [callback]\n */\nCam.prototype.getPresets = function(options, callback) {\n\tif (callback === undefined) { callback = options; options = {};\t}\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetPresets xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) +'</ProfileToken>' +\n\t\t'</GetPresets>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tthis.presets = {};\n\t\t\tvar presets = linerase(data).getPresetsResponse.preset;\n\t\t\tif (typeof presets !== 'undefined') {\n\t\t\t\tif (!Array.isArray(presets)) {\n\t\t\t\t\tpresets = [presets];\n\t\t\t\t}\n\t\t\t\tpresets.forEach(function(preset) {\n\t\t\t\t\tthis.presets[preset.name] = preset.$.token;\n\t\t\t\t}.bind(this));\n\t\t\t}\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.presets, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * /PTZ/ Go to preset\n * @param {object} options\n * @param {string} [options.profileToken]\n * @param {string} options.preset PresetName from {@link Cam#presets} property\n * @param {function} callback\n */\nCam.prototype.gotoPreset = function(options, callback) {\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GotoPreset xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) + '</ProfileToken>' +\n\t\t\t'<PresetToken>' + options.preset + '</PresetToken>' +\n\t\t\t(options.speed ? '<Speed>' + this._panTiltZoomVectors(options.speed) + '</Speed>' : '') +\n\t\t'</GotoPreset>' +\n\t\tthis._envelopeFooter()\n\t}, callback.bind(this));\n};\n\n/**\n * @typedef {object} Cam~PTZStatus\n * @property {object} position\n * @property {number} position.x\n * @property {number} position.y\n * @property {number} position.zoom\n * @property {string} moveStatus\n * @property {?Error} error\n * @property {Date} utcTime\n */\n\n/**\n * @callback Cam~GetPTZStatusCallback\n * @property {?Error} error\n * @property {Cam~PTZStatus} status\n */\n\n/**\n * /PTZ/ Receive cam status\n * @param {Object} [options]\n * @param {string} [options.profileToken={@link Cam#activeSource.profileToken}]\n * @param {Cam~GetPTZStatusCallback} callback\n */\nCam.prototype.getStatus = function(options, callback) {\n\tif (callback === undefined) { callback = options; options = {};\t}\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetStatus xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) +'</ProfileToken>' +\n\t\t'</GetStatus>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tvar res = linerase(data).getStatusResponse.PTZStatus;\n\t\t\tvar status = {\n\t\t\t\tposition: {\n\t\t\t\t\tx: res.position.panTilt.$.x\n\t\t\t\t\t, y: res.position.panTilt.$.y\n\t\t\t\t\t, zoom: res.position.zoom.$.x\n\t\t\t\t}\n\t\t\t\t, moveStatus: res.moveStatus\n\t\t\t\t, error: res.error\n\t\t\t\t, utcTime: res.utcTime\n\t\t\t};\n\t\t}\n\t\tcallback.call(this, err, err ? null : status, xml);\n\t}.bind(this));\n};\n\n/**\n * /PTZ/ Returns the properties of the requested PTZ node, if it exists.\n * Use this function to get maximum number of presets, ranges of admitted values for x, y, zoom, iris, focus\n * @param {Function} callback\n */\nCam.prototype.getNodes = function(callback) {\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetNodes xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\" />' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tvar nodes = this.nodes = {};\n\t\t\tdata[0]['getNodesResponse'].forEach(function(ptzNode) {\n\t\t\t\tnodes[ptzNode['PTZNode'][0].$.token] = linerase(ptzNode['PTZNode'][0]);\n\t\t\t\tdelete nodes[ptzNode['PTZNode'][0].$.token].$;\n\t\t\t});\n\t\t}\n\t\tcallback.call(this, err, nodes, xml);\n\t}.bind(this));\n};\n\n/**\n * /PTZ/ Get an array with configuration names\n * @param {Function} callback\n */\nCam.prototype.getConfigurations = function(callback) {\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetConfigurations xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t'</GetConfigurations>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\tvar configurations = {};\n\t\t\tdata[0]['getConfigurationsResponse'].forEach(function(configuration) {\n\t\t\t\tconfigurations[configuration['PTZConfiguration'][0]['name']] = {\n\t\t\t\t\tuseCount: parseInt(configuration['PTZConfiguration'][0]['useCount'])\n\t\t\t\t\t, nodeToken: configuration['PTZConfiguration'][0]['nodeToken'][0]\n\t\t\t\t\t, defaultPTZSpeed: {\n\t\t\t\t\t\tx: configuration['PTZConfiguration'][0]['defaultPTZSpeed'][0]['panTilt'][0].$.x\n\t\t\t\t\t\t, y: configuration['PTZConfiguration'][0]['defaultPTZSpeed'][0]['panTilt'][0].$.y\n\t\t\t\t\t\t, zoom: configuration['PTZConfiguration'][0]['defaultPTZSpeed'][0]['zoom'][0].$.x\n\t\t\t\t\t}\n\t\t\t\t\t, defaultPTZTimeout: configuration['PTZConfiguration'][0]['defaultPTZTimeout'][0]\n\t\t\t\t};\n\t\t\t});\n\t\t\tthis.configurations = configurations;\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.configurations, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * /PTZ/ Get options for the PTZ configuration\n * @param {string} configurationToken\n * @param {Function} callback\n */\nCam.prototype.getConfigurationOptions = function(configurationToken, callback) {\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetConfigurationOptions xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ConfigurationToken>' + configurationToken + '</ConfigurationToken>' +\n\t\t'</GetConfigurationOptions>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tvar configOptions;\n\t\tif (!err) {\n\t\t\tvar sp = data[0]['getConfigurationOptionsResponse'][0]['PTZConfigurationOptions'][0]['spaces'][0];\n\t\t\tconfigOptions = {\n\t\t\t\tptzTimeout: {\n\t\t\t\t\tmin: data[0]['getConfigurationOptionsResponse'][0]['PTZConfigurationOptions'][0]['PTZTimeout'][0]['min']\n\t\t\t\t\t, max: data[0]['getConfigurationOptionsResponse'][0]['PTZConfigurationOptions'][0]['PTZTimeout'][0]['max']\n\t\t\t\t}\n\t\t\t\t, spaces: {\n\t\t\t\t\tabsolute: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['absolutePanTiltPositionSpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['absolutePanTiltPositionSpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['absolutePanTiltPositionSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, y: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['absolutePanTiltPositionSpace'][0]['YRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['absolutePanTiltPositionSpace'][0]['YRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['absolutePanTiltPositionSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, zoom: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['absoluteZoomPositionSpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['absoluteZoomPositionSpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['absoluteZoomPositionSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t, relative: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['relativePanTiltTranslationSpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['relativePanTiltTranslationSpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['relativePanTiltTranslationSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, y: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['relativePanTiltTranslationSpace'][0]['YRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['relativePanTiltTranslationSpace'][0]['YRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['relativePanTiltTranslationSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, zoom: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['relativeZoomTranslationSpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['relativeZoomTranslationSpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['relativeZoomTranslationSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t, continuous: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['continuousPanTiltVelocitySpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['continuousPanTiltVelocitySpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['continuousPanTiltVelocitySpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, y: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['continuousPanTiltVelocitySpace'][0]['YRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['continuousPanTiltVelocitySpace'][0]['YRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['continuousPanTiltVelocitySpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, zoom: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['continuousZoomVelocitySpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['continuousZoomVelocitySpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['continuousZoomVelocitySpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t, common: {\n\t\t\t\t\t\tx: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['panTiltSpeedSpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['panTiltSpeedSpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['panTiltSpeedSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t\t, zoom: {\n\t\t\t\t\t\t\tmin: parseFloat(sp['zoomSpeedSpace'][0]['XRange'][0]['min'][0])\n\t\t\t\t\t\t\t, max: parseFloat(sp['zoomSpeedSpace'][0]['XRange'][0]['max'][0])\n\t\t\t\t\t\t\t, uri: sp['zoomSpeedSpace'][0]['URI']\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tif (this.configurations[configurationToken]) {\n\t\t\t\textend(this.configurations[configurationToken], configOptions);\n\t\t\t}\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, configOptions, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * /PTZ/ relative move\n * @param {object} options\n * @param {string} [options.profileToken=Cam#activeSource.profileToken]\n * @param {number} [options.x=0] Pan, float within -1 to 1\n * @param {number} [options.y=0] Tilt, float within -1 to 1\n * @param {number} [options.zoom=0] Zoom, float within 0 to 1\n * @param {object} [options.speed] If the speed argument is omitted, the default speed set by the PTZConfiguration will be used.\n * @param {number} [options.speed.x] Pan speed, float within 0 to 1\n * @param {number} [options.speed.y] Tilt speed, float within 0 to 1\n * @param {number} [options.speed.zoom] Zoom speed, float within 0 to 1\n * @param {Cam~RequestCallback} [callback]\n */\nCam.prototype.relativeMove = function(options, callback) {\n\tcallback = callback ? callback.bind(this) : function() {};\n\t// Due to some glitches in testing cam forcibly set undefined move parameters to zero\n\toptions.x = options.x || 0;\n\toptions.y = options.y || 0;\n\toptions.zoom = options.zoom || 0;\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<RelativeMove xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) + '</ProfileToken>' +\n\t\t\t'<Translation>' +\n\t\t\t\tthis._panTiltZoomVectors(options) +\n\t\t\t'</Translation>' +\n\t\t\t(options.speed ? '<Speed>' + this._panTiltZoomVectors(options.speed) + '</Speed>' : '') +\n\t\t'</RelativeMove>' +\n\t\tthis._envelopeFooter()\n\t}, callback.bind(this));\n};\n\n/**\n * /PTZ/ absolute move\n * @param {object} options\n * @param {string} [options.profileToken=Cam#activeSource.profileToken]\n * @param {number} [options.x] Pan, float within -1 to 1\n * @param {number} [options.y] Tilt, float within -1 to 1\n * @param {number} [options.zoom] Zoom, float within 0 to 1\n * @param {object} [options.speed] If the speed argument is omitted, the default speed set by the PTZConfiguration will be used.\n * @param {number} [options.speed.x] Pan speed, float within 0 to 1\n * @param {number} [options.speed.y] Tilt speed, float within 0 to 1\n * @param {number} [options.speed.zoom] Zoom speed, float within 0 to 1\n * @param {Cam~RequestCallback} [callback]\n */\nCam.prototype.absoluteMove = function(options, callback) {\n\tcallback = callback ? callback.bind(this) : function() {};\n\t// Due to some glitches in testing cam forcibly set undefined move parameters to zero\n\toptions.x = options.x || 0;\n\toptions.y = options.y || 0;\n\toptions.zoom = options.zoom || 0;\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<AbsoluteMove xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) + '</ProfileToken>' +\n\t\t\t'<Position>' +\n\t\t\t\tthis._panTiltZoomVectors(options) +\n\t\t\t'</Position>' +\n\t\t\t(options.speed ? '<Speed>' + this._panTiltZoomVectors(options.speed) + '</Speed>' : '') +\n\t\t'</AbsoluteMove>' +\n\t\tthis._envelopeFooter()\n\t}, callback.bind(this));\n};\n\n/**\n * /PTZ/ Operation for continuous Pan/Tilt and Zoom movements\n * @param options\n * @param {string} [options.profileToken=Cam#activeSource.profileToken]\n * @param {number} [options.x=0] pan velocity, float within 0 to 1\n * @param {number} [options.y=0] tilt velocity, float within 0 to 1\n * @param {number} [options.zoom=0] zoom velocity, float within 0 to 1\n * @param {number} [options.timeout=Infinity] timeout in milliseconds\n * @param {Cam~RequestCallback} callback\n */\nCam.prototype.continuousMove = function(options, callback) {\n\tcallback = callback ? callback.bind(this) : function() {};\n\t// Due to some glitches in testing cam forcibly set undefined move parameters to zero\n\toptions.x = options.x || 0;\n\toptions.y = options.y || 0;\n\toptions.zoom = options.zoom || 0;\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<ContinuousMove xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) + '</ProfileToken>' +\n\t\t\t'<Velocity>' +\n\t\t\t\tthis._panTiltZoomVectors(options) +\n\t\t\t'</Velocity>' +\n\t\t\t(options.timeout ? '<Timeout>PT' + (options.timeout / 1000) + 'S</Timeout>' : '') +\n\t\t'</ContinuousMove>' +\n\t\tthis._envelopeFooter()\n\t}, callback.bind(this));\n};\n\n/**\n * Stop ongoing pan, tilt and zoom movements of absolute relative and continuous type\n * @param {object} [options]\n * @param {string} [options.profileToken]\n * @param {boolean|string} [options.panTilt]\n * @param {boolean|string} [options.zoom]\n * @param {Cam~RequestCallback} [callback]\n */\nCam.prototype.stop = function(options, callback) {\n\tif (callback === undefined) {\n\t\tswitch (typeof options) {\n\t\t\tcase 'object': callback = function() {}; break;\n\t\t\tcase 'function': callback = options; options = {}; break;\n\t\t\tdefault: callback = function() {}; options = {};\n\t\t}\n\t}\n\tthis._request({\n\t\tservice: 'ptz'\n\t\t, body: this._envelopeHeader() +\n\t\t'<Stop xmlns=\"http://www.onvif.org/ver20/ptz/wsdl\">' +\n\t\t\t'<ProfileToken>' + (options.profileToken || this.activeSource.profileToken) + '</ProfileToken>' +\n\t\t\t(options.panTilt ? '<PanTilt>' + options.panTilt + '</PanTilt>' : '') +\n\t\t\t(options.zoom ? '<Zoom>' + options.zoom + '</Zoom>' : '') +\n\t\t'</Stop>' +\n\t\tthis._envelopeFooter()\n\t}, callback.bind(this));\n};\n\n/**\n * Create ONVIF soap vector\n * @param [ptz.x]\n * @param [ptz.y]\n * @param [ptz.zoom]\n * @return {string}\n * @private\n */\nCam.prototype._panTiltZoomVectors = function(ptz) {\n\treturn ptz\n\t\t?\n\t(ptz.x !== undefined && ptz.y !== undefined\n\t\t? '<PanTilt x=\"' + ptz.x\n\t+ '\" y=\"' + ptz.y + '\" xmlns=\"http://www.onvif.org/ver10/schema\"/>'\n\t\t: '') +\n\t(ptz.zoom !== undefined\n\t\t? '<Zoom x=\"'\n\t+ ptz.zoom + '\" xmlns=\"http://www.onvif.org/ver10/schema\"/>'\n\t\t: '')\n\t\t: '';\n};\n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/imaging.js":"/**\n * @namespace cam\n * @description Media section for Cam class\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nconst Cam = require('./cam').Cam\n\t, linerase = require('./utils').linerase\n\t;\n\n/**\n * @typedef {object} Cam~ImagingSettings\n * @property {number} brightness\n * @property {number} colorSaturation\n * @property {object} focus\n * @property {string} focus.autoFocusMode\n * @property {number} sharpness\n */\n\n/**\n * @callback Cam~GetImagingSettingsCallback\n * @property {?Error} error\n * @property {Cam~ImagingSettings} status\n */\n\n/**\n * Get the ImagingConfiguration for the requested VideoSource (default - the activeSource)\n * @param {object} [options]\n * @param {string} [options.token] {@link Cam#activeSource.profileToken}\n * @param {Cam~GetImagingSettingsCallback} callback\n */\nCam.prototype.getImagingSettings = function(options, callback) {\n\tif (typeof callback === 'undefined') {\n\t\tcallback = options;\n\t\toptions = {};\n\t}\n\tthis._request({\n\t\tservice: 'imaging'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetImagingSettings xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' +\n\t\t\t'<VideoSourceToken  xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' + ( options.token || this.activeSource.sourceToken ) + '</VideoSourceToken>' +\n\t\t'</GetImagingSettings>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) { \n\t\t\tcallback.call(this, err, err ? null : linerase(data).getImagingSettingsResponse.imagingSettings, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~ImagingSetting\n * @property {string} token Video source token\n * @property {number} brightness\n * @property {number} colorSaturation\n * @property {number} contrast\n * @property {number} sharpness\n */\n\n/**\n * Set the ImagingConfiguration for the requested VideoSource (default - the activeSource)\n * @param {Cam~ImagingSetting} options\n * @param callback\n */\nCam.prototype.setImagingSettings = function(options, callback) {\n\tthis._request({\n\t\tservice: 'imaging'\n\t\t, body: this._envelopeHeader() +\n\t\t'<SetImagingSettings xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' +\n\t\t\t'<VideoSourceToken  xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' +\n\t\t\t\t( options.token || this.activeSource.sourceToken) +\n\t\t\t'</VideoSourceToken>' +\n \n\t\t\t'<ImagingSettings xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' +\n\t\t\t\t( \n\t\t\t\t\toptions.brightness ? \n\t\t\t\t\t(\n\t\t\t\t\t\t'<Brightness xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t\t\toptions.brightness +\n\t\t\t\t\t\t'</Brightness>' \n\t\t\t\t\t) : ''\n\t\t\t\t)\n\n\t\t\t+\n\n\t\t\t\t( \n\t\t\t\t\toptions.colorSaturation ? \n\t\t\t\t\t(\n\t\t\t\t\t\t'<ColorSaturation xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t\t\toptions.colorSaturation +\n\t\t\t\t\t\t'</ColorSaturation>' \n\t\t\t\t\t) : ''\n\t\t\t\t)\n\n\t\t\t+\n\n\t\t\t\t( \n\t\t\t\t\toptions.contrast ? \n\t\t\t\t\t(\n\t\t\t\t\t\t'<Contrast xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t\t\toptions.contrast +\n\t\t\t\t\t\t'</Contrast>' \n\t\t\t\t\t) : ''\n\t\t\t\t)\n\n\t\t\t+\n\n\t\t\t\t( \n\t\t\t\t\toptions.sharpness ? \n\t\t\t\t\t(\n\t\t\t\t\t\t'<Sharpness xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t\t\toptions.sharpness +\n\t\t\t\t\t\t'</Sharpness>' \n\t\t\t\t\t) : ''\n\t\t\t\t)\n\n\t\t\t+\n\t\t\t'</ImagingSettings>' +\n\t\t'</SetImagingSettings>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) { \n\t\t\tcallback.call(this, err, err ? null : linerase(data).setImagingSettingsResponse, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~ImagingServiceCapabilities\n * @property {boolean} ImageStabilization Indicates whether or not Image Stabilization feature is supported\n * @property {boolean} [Presets] Indicates whether or not Imaging Presets feature is supported\n */\n\n/**\n * @callback Cam~GetImagingServiceCapabilitiesCallback\n * @property {?Error} error\n * @property {Cam~ImagingServiceCapabilities} capabilities\n */\n\n/**\n * Returns the capabilities of the imaging service\n * @property {Cam~GetImagingServiceCapabilitiesCallback}\n */\nCam.prototype.getImagingServiceCapabilities = function(callback) {\n\tthis._request({\n\t\tservice: 'imaging'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetServiceCapabilities xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' +\n\t\t'</GetServiceCapabilities>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data[0].getServiceCapabilitiesResponse[0].capabilities[0].$), xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * @typedef {object} Cam~ImagingPreset\n * @property {string} token\n * @property {string} type Indicates Imaging Preset Type\n * @property {string} Name Human readable name of the Imaging Preset\n */\n\n/**\n * @callback Cam~GetCurrentImagingPresetCallback\n * @property {?Error} error\n * @property {Cam~ImagingPreset} preset\n */\n\n/**\n * Get the last Imaging Preset applied\n * @param {object} [options]\n * @param {string} [options.token] Reference token to the VideoSource where the current Imaging Preset should be requested\n * @param {Cam~GetCurrentImagingPresetCallback} callback\n */\nCam.prototype.getCurrentImagingPreset = function(options, callback) {\n\tif (typeof callback === 'undefined') {\n\t\tcallback = options;\n\t\toptions = {};\n\t}\n\tthis._request({\n\t\tservice: 'imaging'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetCurrentPreset xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' +\n\t\t\t'<VideoSourceToken>' + ( options.token || this.activeSource.sourceToken ) + '</VideoSourceToken>' +\n\t\t'</GetCurrentPreset>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).getCurrentPresetResponse.preset, xml);\n\t\t}\n\t}.bind(this));\n};\n\n/**\n * Set the ImagingConfiguration for the requested or current VideoSource\n * @param options\n * @param {string} [options.token] Reference token to the VideoSource to which the specified Imaging Preset should be applied.\n * @param {string} options.presetToken Reference token to the Imaging Preset to be applied to the specified Video Source\n * @param {Cam~RequestCallback} callback\n */\nCam.prototype.setCurrentImagingPreset = function(options, callback) {\n\tthis._request({\n\t\tservice: 'imaging'\n\t\t, body: this._envelopeHeader() +\n\t\t'<SetCurrentPreset xmlns=\"http://www.onvif.org/ver20/imaging/wsdl\" >' +\n\t\t\t'<VideoSourceToken>' + ( options.token || this.activeSource.sourceToken ) + '</VideoSourceToken>' +\n\t\t\t'<PresetToken>' + options.presetToken + '</PresetToken>' +\n\t\t'</SetCurrentPreset>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).setCurrentPresetResponse, xml);\n\t\t}\n\t}.bind(this));\n};","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/recording.js":"/**\n * @namespace cam\n * @description Recording section for Cam class\n * @author Roger Hardiman <opensource@rjh.org.uk>\n * @licence MIT\n */\n\nconst Cam = require('./cam').Cam\n\t, linerase = require('./utils').linerase\n\t;\n\n/**\n * @typedef {object} Cam~RecordingItem\n * @property {string} $.token Recording token\n * @property {string} configuration.source.sourceid\n * @property {string} configuration.content\n * @property {string} configuration.maximumretentiontime\n * @property {string} tracks.track.tracktoken\n * @property {string} tracks.configuration.tracktype\n * @property {string} tracks.configuration.description\n */\n\n/**\n * @callback Cam~GetRecordingsCallback\n * @property {?Error} error\n * @property {Cam~RecordingItem|Array.<Cam~RecordingItem>} recording items\n * @property {string} xml Raw SOAP response\n */\n\n/**\n * Get Recording Items (links Video Sources to Recording Tracks)\n * @param {Cam~GetRecordingsCallback} [callback]\n */\nCam.prototype.getRecordings = function(callback) {\n\tthis._request({\n\t\tservice: 'recording'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetRecordings xmlns=\"http://www.onvif.org/ver10/recording/wsdl\"/>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (!err) {\n\t\t\t/**\n\t\t\t * Recording Item\n\t\t\t * @name Cam#recordingItem\n\t\t\t * @type {Cam~RecordingItem|Array.<Cam~RecordingItem>}\n\t\t\t */\n\t\t\tthis.recordingItems = linerase(data).getRecordingsResponse.recordingItem;\n\t\t}\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, this.recordingItems, xml);\n\t\t}\n\t}.bind(this));\n};\n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/replay.js":"/**\n * @namespace cam\n * @description Replay section for Cam class\n * @author Roger Hardiman <opensource@rjh.org.uk>\n * @licence MIT\n */\n\nconst Cam = require('./cam').Cam\n\t, linerase = require('./utils').linerase\n\t;\n\n/**\n * @callback Cam~ResponseUriCallback\n * @property {string} uri\n */\n\n/**\n * Receive Replay Stream URI\n * @param {Object} [options]\n * @param {string} [options.stream]\n * @param {string} [options.protocol]\n * @param {string} [options.recordingToken]\n * @param {Cam~ResponseUriCallback} [callback]\n */\nCam.prototype.getReplayUri = function(options, callback) {\n\tif (callback === undefined) { callback = options; options = {};\t}\n\tthis._request({\n\t\tservice: 'replay'\n\t\t, body: this._envelopeHeader() +\n\t\t'<GetReplayUri xmlns=\"http://www.onvif.org/ver10/replay/wsdl\">' +\n\t\t\t'<StreamSetup>' +\n\t\t\t\t'<Stream xmlns=\"http://www.onvif.org/ver10/schema\">' + (options.stream || 'RTP-Unicast') +'</Stream>' +\n\t\t\t\t'<Transport xmlns=\"http://www.onvif.org/ver10/schema\">' +\n\t\t\t\t\t'<Protocol>' + (options.protocol || 'RTSP') +'</Protocol>' +\n\t\t\t\t'</Transport>' +\n\t\t\t'</StreamSetup>' +\n\t\t\t'<RecordingToken>' + (options.recordingToken) +'</RecordingToken>' +\n\t\t'</GetReplayUri>' +\n\t\tthis._envelopeFooter()\n\t}, function(err, data, xml) {\n\t\tif (callback) {\n\t\t\tcallback.call(this, err, err ? null : linerase(data).getReplayUriResponse.uri, xml);\n\t\t}\n\t}.bind(this));\n};","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/lib/discovery.js":"/**\n * @namespace discovery\n * @description Discovery module\n * @author Andrew D.Laptev <a.d.laptev@gmail.com>\n * @licence MIT\n */\n\nconst\n\tCam = require('./cam').Cam\n\t, events = require('events')\n\t, guid = require('./utils').guid\n\t, linerase = require('./utils').linerase\n\t, parseSOAPString = require('./utils').parseSOAPString\n\t, url = require('url')\n\t, os = require('os')\n\t;\n\n/**\n * Discovery singleton\n * @type {Object}\n * @class\n */\nvar Discovery = Object.create(new events.EventEmitter());\n\n/**\n * @callback Discovery~ProbeCallback\n * @property {?Error} error\n * @property {Array<Cam|object>} found devices\n */\n\n/**\n * Discover NVT devices in the subnetwork\n * @param {object} [options]\n * @param {number} [options.timeout=5000] timeout in milliseconds for discovery responses\n * @param {boolean} [options.resolve=true] set to `false` if you want omit creating of Cam objects\n * @param {string} [options.messageId=GUID] WS-Discovery message id\n * @param {string} [options.device=defaultroute] Interface to bind on for discovery ex. `eth0`\n * @param {Discovery~ProbeCallback} [callback] timeout callback\n * @fires Discovery#device\n * @fires Discovery#error\n * @example\n * var onvif = require('onvif');\n * onvif.Discovery.on('device', function(cam){\n *   // function would be called as soon as NVT responses\n *   cam.username = <USERNAME>;\n *   cam.password = <PASSWORD>;\n *   cam.connect(console.log);\n * })\n * onvif.Discovery.probe();\n * @example\n * var onvif = require('onvif');\n * onvif.Discovery.probe(function(err, cams) {\n *   // function would be called only after timeout (5 sec by default)\n *   if (err) { throw err; }\n *   cams.forEach(function(cam) {\n *       cam.username = <USERNAME>;\n *       cam.password = <PASSWORD>;\n *       cam.connect(console.log);\n *   });\n * });\n */\nDiscovery.probe = function(options, callback) {\n\tif (callback === undefined) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t} else {\n\t\t\toptions = options || {};\n\t\t}\n\t}\n\tcallback = callback || function() {};\n\n\tvar cams = {}\n\t\t, errors = []\n\t\t, messageID = 'urn:uuid:' + (options.messageId || guid())\n\t\t, request = new Buffer(\n\t\t\t'<Envelope xmlns=\"http://www.w3.org/2003/05/soap-envelope\" xmlns:dn=\"http://www.onvif.org/ver10/network/wsdl\">' +\n\t\t\t\t'<Header>' +\n\t\t\t\t\t'<wsa:MessageID xmlns:wsa=\"http://schemas.xmlsoap.org/ws/2004/08/addressing\">' + messageID + '</wsa:MessageID>' +\n\t\t\t\t\t'<wsa:To xmlns:wsa=\"http://schemas.xmlsoap.org/ws/2004/08/addressing\">urn:schemas-xmlsoap-org:ws:2005:04:discovery</wsa:To>' +\n\t\t\t\t\t'<wsa:Action xmlns:wsa=\"http://schemas.xmlsoap.org/ws/2004/08/addressing\">http://schemas.xmlsoap.org/ws/2005/04/discovery/Probe</wsa:Action>' +\n\t\t\t\t'</Header>' +\n\t\t\t\t'<Body>' +\n\t\t\t\t\t'<Probe xmlns=\"http://schemas.xmlsoap.org/ws/2005/04/discovery\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">' + \n\t\t\t\t\t\t'<Types>dn:NetworkVideoTransmitter</Types>' +\n\t\t\t\t\t\t'<Scopes />' +\n\t\t\t\t\t'</Probe>' +\n\t\t\t\t'</Body>' +\n\t\t\t'</Envelope>' \n\t\t)\n\t\t, socket = require('dgram').createSocket('udp4');\n\n\tsocket.on('error', function(err) {\n\t\tDiscovery.emit('error', err);\n\t\tcallback(err);\n\t});\n\n\tconst listener = function(msg, rinfo) {\n\t\tparseSOAPString(msg.toString(), function(err, data, xml) {\n\t\t\t// TODO check for matching RelatesTo field and messageId\n\t\t\tif (err || !data[0].probeMatches) {\n\t\t\t\terrors.push(err || new Error('Wrong SOAP message from ' + rinfo.address + ':' + rinfo.port, xml));\n\t\t\t\t/**\n\t\t\t\t * Indicates error response from device.\n\t\t\t\t * @event Discovery#error\n\t\t\t\t * @type {string}\n\t\t\t\t */\n\t\t\t\tDiscovery.emit('error', 'Wrong SOAP message from ' + rinfo.address + ':' + rinfo.port, xml);\n\t\t\t} else {\n\t\t\t\tdata = linerase(data);\n\n\t\t\t\t// Possible to get multiple matches for the same camera\n\t\t\t\t// when your computer has more than one network adapter in the same subnet\n\t\t\t\tvar camAddr = data.probeMatches.probeMatch.endpointReference.address;\n\t\t\t\tif (!cams[camAddr]) {\n\t\t\t\t\tvar cam;\n\t\t\t\t\tif (options.resolve !== false) {\n\t\t\t\t\t\tvar camUri = url.parse(data.probeMatches.probeMatch.XAddrs);\n\t\t\t\t\t\tcam = new Cam({\n\t\t\t\t\t\t\thostname: camUri.hostname\n\t\t\t\t\t\t\t, port: camUri.port\n\t\t\t\t\t\t\t, path: camUri.path\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcam = data;\n\t\t\t\t\t}\n\t\t\t\t\tcams[camAddr] = cam;\n\t\t\t\t\t/**\n\t\t\t\t\t * Indicates discovered device.\n\t\t\t\t\t * @event Discovery#device\n\t\t\t\t\t * @type {Cam|object}\n\t\t\t\t\t */\n\t\t\t\t\tDiscovery.emit('device', cam, rinfo, xml);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\n\t// If device is specified try to bind to that interface\n\tif (options.device) {\n\t\tvar interfaces = os.networkInterfaces();\n\t\t// Try to find the interface based on the device name\n\t\tif (options.device in interfaces) {\n\t\t\tinterfaces[options.device].some(function(address) {\n\t\t\t\t// Only use IPv4 addresses\n\t\t\t\tif (address.family === 'IPv4') {\n\t\t\t\t\tsocket.bind(null, address.address);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tsocket.on('message', listener);\n\tsocket.send(request, 0, request.length, 3702, '239.255.255.250');\n\n\tsetTimeout(function() {\n\t\tsocket.removeListener('message', listener);\n\t\tsocket.close();\n\t\tcallback(errors.length ? errors : null, Object.keys(cams).map(function(addr) { return cams[addr]; }));\n\t}.bind(this), options.timeout || 5000);\n};\n\nmodule.exports = {\n\tDiscovery: Discovery\n};\n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/example2.js":"/**\n * Created by Roger Hardiman <opensource@rjh.org.uk>\n *\n * Brute force scan of the network looking for ONVIF devices\n * Displays the time and date of each device\n *          the make and model\n *          the default RTSP address\n * This DOES NOT use ONVIF Discovery. This softweare tries each IP address in\n * turn which allows it to work on networks where ONVIF Discovery does not work\n * (eg on Layer 3 routed networks)\n *\n */\n\nvar IP_RANGE_START = '192.168.1.1',\n    IP_RANGE_END = '192.168.1.254',\n    PORT_LIST = [80, 7575, 8000, 8080, 8081],\n    USERNAME = 'admin',\n    PASSWORD = 'admin';\n\nvar Cam = require('./lib/onvif').Cam;\nvar flow = require('nimble');\n\nvar ip_list = generate_range(IP_RANGE_START, IP_RANGE_END);\nvar port_list = PORT_LIST;\n\n// hide error messages\nconsole.error = function() {};\n\n// try each IP address and each Port\nip_list.forEach(function(ip_entry) {\n    port_list.forEach(function(port_entry) {\n\n        console.log(ip_entry + ' ' + port_entry);\n\n        new Cam({\n            hostname: ip_entry,\n            username: USERNAME,\n            password: PASSWORD,\n            port: port_entry,\ntimeout : 5000\n        }, function CamFunc(err) {\n            if (err) return;\n\n            var cam_obj = this;\n\n            var got_date;\n            var got_info;\n            var got_live_stream;\n            var got_recordings;\n            var got_replay_stream;\n\n            // Use Nimble to execute each ONVIF function in turn\n            // This is used so we can wait on all ONVIF replies before\n            // writing to the console\n            flow.series([\n                function(callback) {\n                    cam_obj.getSystemDateAndTime(function(err, date, xml) {\n                        if (!err) got_date = date;\n                        callback();\n                    });\n                },\n                function(callback) {\n                    cam_obj.getDeviceInformation(function(err, info, xml) {\n                        if (!err) got_info = info;\n                        callback();\n                    });\n                },\n                function(callback) {\n                try {\n                    cam_obj.getStreamUri({\n                        protocol: 'RTSP'\n                    }, function(err, stream, xml) {\n                        if (!err) got_live_stream = stream;\n                        callback();\n                    });\n                } catch(err) {callback();}\n                },\n                function(callback) {\n                    cam_obj.getRecordings(function(err, recordings, xml) {\n                        if (!err) got_recordings = recordings;\n                        callback();\n                    });\n                },\n                function(callback) {\n                    // Get Recording URI for the first recording on the NVR\n                    if (got_recordings) {\n                        cam_obj.getReplayUri({\n                            protocol: 'RTSP',\n                            recordingToken: got_recordings[0].recordingToken\n                        }, function(err, stream, xml) {\n                            if (!err) got_replay_stream = stream;\n                            callback();\n                        });\n                    } else {\n                        callback();\n                    }\n                },\n                function(callback) {\n                    console.log('------------------------------');\n                    console.log('Host: ' + ip_entry + ' Port: ' + port_entry);\n                    console.log('Date: = ' + got_date);\n                    console.log('Info: = ' + JSON.stringify(got_info));\n                    if (got_live_stream) {\n                        console.log('First Live Stream: = ' + JSON.stringify(got_live_stream));\n                    }\n                    if (got_replay_stream) {\n                        console.log('First Replay Stream: = ' + JSON.stringify(got_replay_stream));\n                    }\n                    console.log('------------------------------');\n                    callback();\n                },\n\n            ]); // end flow\n\n        });\n    }); // foreach\n}); // foreach\n\n\nfunction generate_range(start_ip, end_ip) {\n  var start_long = toLong(start_ip);\n  var end_long = toLong(end_ip);\n  if (start_long > end_long) {\n    var tmp=start_long;\n    start_long=end_long\n    end_long=tmp;\n  }\n  var range_array = [];\n  var i;\n  for (i=start_long; i<=end_long;i++) {\n    range_array.push(fromLong(i));\n  }\n  return range_array;\n}\n\n//toLong taken from NPM package 'ip' \nfunction toLong(ip) {\n  var ipl = 0;\n  ip.split('.').forEach(function(octet) {\n    ipl <<= 8;\n    ipl += parseInt(octet);\n  });\n  return(ipl >>> 0);\n};\n\n//fromLong taken from NPM package 'ip' \nfunction fromLong(ipl) {\n  return ((ipl >>> 24) + '.' +\n      (ipl >> 16 & 255) + '.' +\n      (ipl >> 8 & 255) + '.' +\n      (ipl & 255) );\n};\n \n","/home/travis/build/npmtest/node-npmtest-onvif/node_modules/onvif/example3.js":"/**\n * NodeJS ONVIF PTZ and Presets Test\n *\n * Created by Roger Hardiman <opensource@rjh.org.uk>\n *\n * Read the cursor keys and send ONVIF PTZ commands to the camera\n *\n * There are a few challenges to reading the keyboard\n * Firstly there is no 'keyup' event. So we use a Timer to schedule an ONVIF\n * Stop Command to be sent after a short delay.\n * If we send a new 'move' command (eg change direction or keyboard\n * auto-repeat) any pending Stop commands are no longer required and are\n * cleared and a new Stop command is scheduled to be sent after a short delay.\n *\n * Secondly we need to handle auto-repeat if a key is held down so we pause\n * and resume stdin.\n *\n * Finally we need to use the completion callbacks for ONVIF functions\n * so that we only send a new ONVIF 'move' command after the previous one has\n * finished to prevent overlapping commands.\n *\n * The program also sends Goto Preset commands.\n * The program gets a list of ONVIF presets. Keys 1..9 are used to send\n * Goto Preset on the first 9 preset commands.\n *\n * The GetPresets command is left as an asyncronous command\n * and the presets list may come in some time after the StreamURI is displayed\n * \n */\n\nvar HOSTNAME = '192.168.1.128',\nPORT = 80,\nUSERNAME = '',\nPASSWORD = '',\nSTOP_DELAY_MS = 50;\n\nvar Cam = require('./lib/onvif').Cam;\nvar keypress = require('keypress');\n\nnew Cam({\n\thostname : HOSTNAME,\n\tusername : USERNAME,\n\tpassword : PASSWORD,\n\tport : PORT,\n\ttimeout : 10000\n}, function CamFunc(err) {\n\tif (err) {\n\t\tconsole.log(err);\n\t\treturn;\n\t}\n\n\tvar cam_obj = this;\n\tvar stop_timer;\n\tvar ignore_keypress = false;\n\tvar preset_names = [];\n\tvar preset_tokens = [];\n\n\tcam_obj.getStreamUri({\n\t\tprotocol : 'RTSP'\n\t},\t// Completion callback function\n\t\t// This callback is executed once we have a StreamUri\n\t\tfunction (err, stream, xml) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tconsole.log('------------------------------');\n\t\t\t\tconsole.log('Host: ' + HOSTNAME + ' Port: ' + PORT);\n\t\t\t\tconsole.log('Stream: = ' + stream.uri);\n\t\t\t\tconsole.log('------------------------------');\n\n\t\t\t\t// start processing the keyboard\n\t\t\t\tread_and_process_keyboard();\n\t\t\t}\n\t\t}\n\t);\n\n\tcam_obj.getPresets({}, // use 'default' profileToken\n\t\t// Completion callback function\n\t\t// This callback is executed once we have a list of presets\n\t\tfunction (err, stream, xml) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(\"GetPreset Error \"+err);\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// loop over the presets and populate the arrays\n\t\t\t\t// Do this for the first 9 presets\n\t\t\t\tconsole.log(\"GetPreset Reply\");\n\t\t\t\tvar count = 1;\n\t\t\t\tfor(var item in stream) {\n\t\t\t\t\tvar name = item;          //key\n\t\t\t\t\tvar token = stream[item]; //value\n\t\t\t\t\t// It is possible to have a preset with a blank name so generate a name\n\t\t\t\t\tif (name.length == 0) name='no name ('+token+')';\n\t\t\t\t\tpreset_names.push(name);\n\t\t\t\t\tpreset_tokens.push(token);\n\n\t\t\t\t\t// Show first 9 preset names to user\n\t\t\t\t\tif (count < 9) {\n\t\t\t\t\t\tconsole.log('Press key '+count+ ' for preset \"' + name + '\"');\n\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t);\n\n\n\tfunction read_and_process_keyboard() {\n\t\t// listen for the \"keypress\" events\n\t\tkeypress(process.stdin);\n\t\tprocess.stdin.setRawMode(true);\n\t\tprocess.stdin.resume();\n\n\t\tconsole.log('');\n\t\tconsole.log('Use Cursor Keys to move camera. + and - to zoom. q to quit');\n\n\t\t// keypress handler\n\t\tprocess.stdin.on('keypress', function (ch, key) {\n\n\t\t\t/* Exit on 'q' or 'Q' or 'CTRL C' */\n\t\t\tif ((key && key.ctrl && key.name == 'c')\n\t\t\t\t || (key && key.name == 'q')) {\n\t\t\t\tprocess.exit();\n\t\t\t}\n\n\t\t\tif (ignore_keypress) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (key) {\n\t\t\t\tconsole.log('got \"keypress\"',key.name);\n\t\t\t} else {\n\t\t\t\tif (ch)console.log('got \"keypress character\"',ch);\n\t\t\t}\n\n\n\t\t\tif      (key && key.name == 'up')    move(0,1,0,'up');\n\t\t\telse if (key && key.name == 'down')  move(0,-1,0,'down');\n\t\t\telse if (key && key.name == 'left')  move(-1,0,0,'left');\n\t\t\telse if (key && key.name == 'right') move(1,0,0,'right');\n\t\t\telse if (ch  && ch       == '-')     move(0,0,-1,'zoom out');\n\t\t\telse if (ch  && ch       == '+')     move(0,0,1,'zoom in');\n\t\t\t// On English keyboards '+' is \"Shift and = key\"\n\t\t\t// Accept the \"=\" key as zoom in\n\t\t\telse if (ch  && ch       == '=')     move(0,0,1,'zoom in');\n\t\t\telse if (ch  && ch>='1' && ch <='9') goto_preset(ch);\n\t\t});\n\t}\n\n\n\tfunction move(x_speed, y_speed, zoom_speed, msg) {\n\t\t// Step 1 - Turn off the keyboard processing (so keypresses do not buffer up)\n\t\t// Step 2 - Clear any existing 'stop' timeouts. We will re-schedule a new 'stop' command in this function \n\t\t// Step 3 - Send the Pan/Tilt/Zoom 'move' command.\n\t\t// Step 4 - In the callback from the PTZ 'move' command we schedule the ONVIF Stop command to be executed after a short delay and re-enable the keyboard\n\n\t\t// Pause keyboard processing\n\t\tignore_keypress = true;\n\n\t\t// Clear any pending 'stop' commands\n\t\tif (stop_timer) clearTimeout(stop_timer);\n\n\t\t// Move the camera\n\t\tconsole.log('sending move command ' + msg);\n\t\tcam_obj.continuousMove({x : x_speed,\n\t\t\t\t\ty : y_speed,\n\t\t\t\t\tzoom : zoom_speed } ,\n\t\t\t\t// completion callback function\n\t\t\t\tfunction (err, stream, xml) {\n\t\t\t\t\tif (err) {\n\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconsole.log('move command sent '+ msg);\n\t\t\t\t\t\t// schedule a Stop command to run in the future \n\t\t\t\t\t\tstop_timer = setTimeout(stop,STOP_DELAY_MS);\n\t\t\t\t\t}\n\t\t\t\t\t// Resume keyboard processing\n\t\t\t\t\tignore_keypress = false;\n\t\t\t\t});\n\t\t}\n\n\n\tfunction stop() {\n\t\t// send a stop command, stopping Pan/Tilt and stopping zoom\n\t\tconsole.log('sending stop command');\n\t\tcam_obj.stop({panTilt: true, zoom: true},\n\t\t\tfunction (err,stream, xml){\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('stop command sent');\n\t\t\t\t}\n\t\t\t});\n\t}\n\n\n\tfunction goto_preset(number) {\n\t\tif (number > preset_names.length) {\n\t\t\tconsole.log (\"No preset \" + number);\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.log('sending goto preset command '+preset_names[number-1]);\n\t\tcam_obj.gotoPreset({ preset : preset_tokens[number-1] } ,\n\t\t\t// completion callback function\n\t\t\tfunction (err, stream, xml) {\n\t\t\t\tif (err) {\n\t\t\t\t\tconsole.log(err);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.log('goto preset command sent ');\n\t\t\t\t}\n\t\t\t});\n\t}\n});\n"}